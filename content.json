{"pages":[{"title":"关于","text":"这里是来自HB 襄阳四中的高一OIer zgjjjj 的博客呢~ UPD：这弱鸡高二了","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"notes","text":"这里会放一些zgjjj记的小知识点~ $\\LaTeX$公式大全 感谢原作者Iowa_BattleShip 数列$&lt;1, \\dbinom{c}{1}, \\dbinom{c + 1}{2}, \\dbinom{c + 2}{3}, \\cdots&gt;$的生成函数为$G(z) = \\frac{1}{(1-z) ^ c}$ 证明： 从右边考虑： $\\frac{1}{(1-z) ^ c} = (1 - z) ^ {-c}$ 广义二项式定理展开： 原式 $= \\sum\\limits_{k\\geq 0}^{\\infty}\\dbinom{-c}{k}\\times (-z) ^ k$ $= {\\sum\\limits_{k\\geq 0}^{\\infty} \\frac{(-c)^{\\underline{k}}}{k!}\\times (-1) ^ k \\times z ^ k} ^ {[1]}$ 其中： ${(-c)} ^ {\\underline{k}} $ $= (-c) \\times (-c - 1) \\times (-c - 2) \\times\\cdots\\times (-c - k + 1)$ $= (-1) ^ k \\times c\\times (c + 1) \\times (c + 2) \\times \\cdots \\times (c + k - 1)$ $= (-1) ^ k \\times (c + k - 1) ^ {\\underline{k}}$ 代回原式： 原式 $=\\sum\\limits_{k \\geq 0} ^ {\\infty}\\frac{(-1)^k\\times (c + k - 1) ^{\\underline{k}}}{k!} \\times (-1) ^ k \\times z ^ k$ $= \\sum\\limits_{k \\geq 0} ^ {\\infty}\\frac{(-1) ^ {2k} \\times (c + k - 1) ^ {\\underline{k}}}{k!} \\times z^k$ 又因为： $(-1)^{2k} = 1$ 所以： 原式$=\\sum\\limits_{k\\geq 0}^{\\infty}\\frac{(c + k - 1) ^ {\\underline{k}}}{k!}\\times z^k$ 由组合数推广定义： 原式$=\\sum\\limits_{k\\ge 0} ^ {\\infty} \\dbinom{c + k - 1}{k} \\times z ^ k$ 是由定义得到的原数列的生成函数。 ${}^1a ^ {\\underline{k}} = \\prod\\limits_{i = 1} ^ {k} (a - i + 1)$","link":"/notes/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"","text":"Bookmark for NexT Introduce Bookmark is a plugin that allow the users save their reading position. The users could just click the bookmark icon (like 🔖) in left-top of the page to save the position. And when they visit your blog in the next time, they can continue the last reading position by clicking the bookmark icon from the home page. Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1bookmark: true And, if you wants to use the CDN, then need to set: 123vendors: ... bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js Update 12$ cd themes/next/source/lib/bookmark$ git pull","link":"/lib/bookmark/README.html"},{"title":"","text":"(function (global) { 'use strict'; var storage = global.localStorage; if (storage == null) { // if the localStorage is not exists storage = { // eslint-disable-next-line getItem: function () { return null }, setItem: function () { }, removeItem: function () { }, clear: function () { }, }; } // get the saved bookmark object var getBookmark = function () { var mark = storage.getItem('bookmark'); if (mark == null) { return null; } try { return JSON.parse(mark); } catch (e) { // invalid object saved in the storage // console.warn('Invalid bookmark object.'); return null; } }; var link; // register everything var init = function () { // bookmark-link style var style = global.document.createElement('style'); style.type = 'text/css'; var text = '.book-mark-link{' + 'border-bottom:none;' + 'display:block;' + 'position:fixed;' + 'color:#222;' + 'font-size:26px !important;' + 'top:-10px;left:20px;' + 'transition:.3s;' + '}' + '.book-mark-link:hover,.book-mark-link-fixed{top:-2px}' // do not show when the width is not enough + '@media(max-width:1090px){.book-mark-link{display:none}}'; text = global.document.createTextNode(text); style.appendChild(text); global.document.head.appendChild(style); // create a link element // eslint-disable-next-line max-len link = $(''); $(global.document.body).append(link); var currentTop = 0; // scroll event $(global).on('scroll.bookmark', function () { var top = global.document.documentElement.scrollTop; if (top > 0) { if (currentTop === 0) { link.removeClass('book-mark-link-fixed'); currentTop = top; } } else { if (currentTop > 0) { !link.hasClass('book-mark-link-fixed') && link.addClass('book-mark-link-fixed'); currentTop = 0; } } }); }; var loadBookmark = function () { var mark = getBookmark(); if (mark == null) { return; } // found the bookmark $(function () { init(); link.attr('href', mark.lastUri + '#book:mark'); }); }; var doScroll = function (top) { if (!isNaN(top)) { $(function () { // eslint-disable-next-line max-len $(global.document.documentElement).animate({ 'scrollTop': top }, 'fast'); }); } }; var doSaveScroll = function (path, mark) { if (mark == null) { mark = {}; } var top = global.document.documentElement.scrollTop; mark.lastUri = path; mark[path] = top; storage.setItem('bookmark', JSON.stringify(mark)); link.animate({ top: -26 }, 'fast', function () { setTimeout(function () { link.css('top', ''); }, 400); }); return mark; }; var scrollToMark = function (trigger, hash) { var path = global.location.pathname; var mark = getBookmark(); $(function () { init(); // save the position by clicking the icon link.click(function () { mark = doSaveScroll(path, mark); return false; }); // register beforeunload event when the trigger is auto if (trigger === 'auto') { // register beforeunload event global.addEventListener('beforeunload', function () { doSaveScroll(path, mark); }); } // auto scroll to the position if (mark == null) { return; } // and if the page opens with a specific hash, just jump out var skips = [hash, '#comments']; // eslint-disable-next-line if (skips.filter(function (h) { return h === global.location.hash }).length > 0) { return; } doScroll(mark[path]); }); }; global.bookmark = { loadBookmark: loadBookmark, scrollToMark: scrollToMark, }; })(window);","link":"/lib/bookmark/index.js"},{"title":"","text":"!function(o){\"use strict\";var n=o.localStorage;null==n&&(n={getItem:function(){return null},setItem:function(){},removeItem:function(){},clear:function(){}});var t,e=function(){var o=n.getItem(\"bookmark\");if(null==o)return null;try{return JSON.parse(o)}catch(o){return null}},a=function(){var n=o.document.createElement(\"style\");n.type=\"text/css\";var e=\".book-mark-link{border-bottom:none;display:block;position:fixed;color:#222;font-size:26px !important;top:-10px;left:20px;transition:.3s;}.book-mark-link:hover,.book-mark-link-fixed{top:-2px}@media(max-width:1090px){.book-mark-link{display:none}}\";e=o.document.createTextNode(e),n.appendChild(e),o.document.head.appendChild(n),t=$(''),$(o.document.body).append(t);var a=0;$(o).on(\"scroll.bookmark\",function(){var n=o.document.documentElement.scrollTop;n>0?0===a&&(t.removeClass(\"book-mark-link-fixed\"),a=n):a>0&&(!t.hasClass(\"book-mark-link-fixed\")&&t.addClass(\"book-mark-link-fixed\"),a=0)})},r=function(e,a){null==a&&(a={});var r=o.document.documentElement.scrollTop;return a.lastUri=e,a[e]=r,n.setItem(\"bookmark\",JSON.stringify(a)),t.animate({top:-26},\"fast\",function(){setTimeout(function(){t.css(\"top\",\"\")},400)}),a};o.bookmark={loadBookmark:function(){var o=e();null!=o&&$(function(){a(),t.attr(\"href\",o.lastUri+\"#book:mark\")})},scrollToMark:function(n,l){var i=o.location.pathname,c=e();$(function(){var e;a(),t.click(function(){return c=r(i,c),!1}),\"auto\"===n&&o.addEventListener(\"beforeunload\",function(){r(i,c)}),null!=c&&([l,\"#comments\"].filter(function(n){return n===o.location.hash}).length>0||(e=c[i],isNaN(e)||$(function(){$(o.document.documentElement).animate({scrollTop:e},\"fast\")})))})}}}(window);","link":"/lib/bookmark/bookmark.min.js"},{"title":"","text":"{\"name\":\"theme-next-bookmark\",\"version\":\"1.0.2\",\"description\":\"A plugin of local-bookmarks for NexT theme.\",\"main\":\"index.js\",\"scripts\":{\"test\":\"eslint index.js\",\"dist\":\"eslint index.js && uglifyjs --compress --mangle -o bookmark.min.js -- index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-bookmark.git\"},\"keywords\":[\"hexo\",\"theme-next\",\"plugin\",\"bookmark\"],\"author\":\"Tsanie Lily\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-bookmark/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-bookmark#readme\",\"devDependencies\":{\"eslint\":\"^4.17.0\",\"eslint-config-google\":\"^0.9.1\",\"uglify-js\":\"^3.3.10\"}}","link":"/lib/bookmark/package.json"}],"posts":[{"title":"CF1039D You Are Given a Tree 解题报告","text":"神仙题，写了一上午 题目链接CF1039D You Are Given a Tree 题意简述给你一棵树，分别求出划分成包含点数$k\\in[1,n]$的链时最大的链的个数。 解题思想感谢小粉兔教我这道题QwQ OwenOwl说要整体二分，那是啥 首先考虑暴力怎么打，对于每一个$k$，可以贪心地去做，一直找能连接的点，直到长度第一次$\\geq k$，这时链数++，继续找下一段。时间复杂度为$O(n ^ 2)$ 然后分析一波样例，我们发现对于$k\\in(\\sqrt n, n]$，答案是单减的，并且与整除分块相似，中间的某一段答案是一样的，所以我们可以二分找到一个段的右端点，然后暴力check()，更新整段的答案。这里的复杂度是$O(n\\sqrt n \\log n)$（log二分，根号区间，O(n)check）。 所以我们对于剩下的区间$[1, \\sqrt n]$，直接暴力做，复杂度也是$O(n\\sqrt n)$的，不会拖后腿。 总复杂度为$O(n\\sqrt n\\log n)$ 这个复杂度已经可以过了 但是我们发现分治的两个区间复杂度并不均衡，所以考虑通过分配不同的分治范围来均衡掉两个不同的操作时间。 我们发现，对于大段区间，二分的复杂度是$O(\\log n)$的，而暴力部分区间是$O(n)$的，于是我们可以通过设置区块分界点为$O(\\sqrt{(n \\times \\log n)}) = O(\\sqrt{n \\log n})$来均衡两个复杂度。 60个点一共快了10s。。。 根号nlogn断点 根号n断点 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;namespace FastIO{ inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 100010;const int M = N &lt;&lt; 1;template &lt;typename T&gt; inline T max(T a, T b) {return a &gt; b ? a : b;}int n, size;int head[N], ver[M], nxt[M], cnt;int fa[N], ptn[N], idx;int d[N], ans[N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt; ver[++cnt] = x, nxt[cnt] = head[y], head[y] = cnt;}void dfs(int x) { for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x]) continue; fa[y] = x; dfs(y); } ptn[++idx] = x;}inline int find(int k) { int ans = 0; for(register int i = 1; i &lt;= n; i++) d[i] = 1; for(register int i = 1; i &lt;= n; i++) { int x = ptn[i]; if(fa[x] &amp;&amp; (~d[fa[x]]) &amp;&amp; (~d[x])) { if(d[x] + d[fa[x]] &gt;= k) { ans++; d[fa[x]] = -1; } else { d[fa[x]] = max(d[fa[x]], d[x] + 1); } } } return ans;}int main() { n = read(); size = sqrt(n * (log(n) / log(2))); for(register int i = 1; i &lt; n; i++) { int x = read(), y = read(); add(x, y); } dfs(1); ans[1] = n; for(register int i = 2; i &lt;= size; i++) { ans[i] = find(i); } for(register int i = size + 1, l, r, k; i &lt;= n; i = l + 1) { l = i, r = n, k = find(i); while(l + 1 &lt; r) { int mid = (l + r) &gt;&gt; 1; if(find(mid) == k) l = mid; else r = mid; } for(register int j = i; j &lt;= l; j++) ans[j] = k; } for(register int i = 1; i &lt;= n; i++) { write(ans[i]); } return 0;}","link":"/2019/08/26/CF1039D-You-Are-Given-a-Tree-解题报告/"},{"title":"CF1207B Square Filling 解题报告","text":"考场上想了个很$naive$的dp，$\\color{black}{Q}\\color{red}{uank}$大爷提醒后才发现没有最优化。 身败名裂 题目链接(Luogu)CF1207B Square Filling 题意简述给你一个01矩阵，每次操作可将一个$2\\times 2$的正方形全部赋值为$1$，问你能不能将一个空矩阵变成目标矩阵。 解题思想既然题目中不要求最优解，我们就不需要考虑少覆盖几个正方形。 直接从$(1, 1)$开始枚举，依次考虑以当前点为左上角的正方形，如果可以覆盖，直接覆盖并记录路径。 然后在全部覆盖完后将答案矩阵和目标矩阵进行对比，若一致则输出方案。 注意不要越界。 参考代码123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;const int N = 100;int a[N][N], b[N][N];int n, m;int x[N * N], y[N * N], cnt;int main() { scanf(\"%d%d\", &amp;n, &amp;m); for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= m; j++) { scanf(\"%d\", &amp;a[i][j]); } } for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= m; j++) { if(a[i][j] &amp;&amp; a[i + 1][j] &amp;&amp; a[i][j + 1] &amp;&amp; a[i + 1][j + 1] &amp;&amp; i + 1 &lt;= n &amp;&amp; j + 1 &lt;= m) b[i][j] = b[i + 1][j] = b[i][j + 1] = b[i + 1][j + 1] = 1, x[++cnt] = i, y[cnt] = j; } } for(register int i = 1; i &lt;= n; i++) for(register int j = 1; j &lt;= m; j++) if(a[i][j] != b[i][j]) return puts(\"-1\"), 0; printf(\"%d\\n\", cnt); for(register int i = 1; i &lt;= cnt; i++) { printf(\"%d %d\\n\", x[i], y[i]); } return 0;}","link":"/2019/08/25/CF1207B-Square-Filling-解题报告/"},{"title":"CF1204C Anna, Svyatoslav and Maps 解题报告","text":"考场没做出来，身败名裂 题目链接(Luogu)CF1204C Anna, Svyatoslav and Maps 题意简述给你一张图和一个序列，要求找出其最短的子序列，满足两个序列首尾元素相同，并且子序列中每个点都在原序列最短路径上（好像没说清楚 解题思想看到这个$n$很小，我们考虑Floyd先求出最短路。 然后对于原序列，我们贪心地考虑每三个点：如果中间的点在另外两个点的最短路径上，我们就可以去掉它。 这个可以通过Floyd后得到的距离进行判断。 所以，我们需要维护一下这三个点：对于每一个被去掉的点，显然不用考虑，然后当前用来更新的点肯定是完成的序列中最后一个被更新的，所以我们只需要维护答案队列的首。 考虑使用栈：对于每一个原序列的元素，取出它与后一个元素与栈顶元素进行比较更新：若答案符合上述要求，则将中间元素加入栈中，否则跳过。 需要注意的是，序列的N与图的N不是同一个，数组要开够。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 110;const int M = 1e6 + 6;template &lt;typename T&gt; inline T min(T a, T b) {return a &lt; b ? a : b;}int n, m, a[M];int f[N][N];char mp[N][N];int s[M], stop;int main() { n = read(); for(register int i = 1; i &lt;= n; i++) { scanf(\"%s\", mp[i] + 1); } for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= n; j++) { if(mp[i][j] == '0') f[i][j] = 0x3f3f3f3f; else f[i][j] = 1; } } for(register int i = 1; i &lt;= n; i++) { f[i][i] = 0; } m = read(); for(register int i = 1; i &lt;= m; i++) { a[i] = read(); } for(register int k = 1; k &lt;= n; k++) { for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= n; j++) { f[i][j] = min(f[i][j], f[i][k] + f[k][j]); } } } s[++stop] = a[1]; for(register int i = 2; i &lt;= m; i++) { if(f[s[stop]][a[i + 1]] != f[s[stop]][a[i]] + f[a[i]][a[i + 1]]) s[++stop] = a[i]; } printf(\"%d\\n\", stop); for(register int i = 1; i &lt;= stop; i++) printf(\"%d \", s[i]); return 0;}","link":"/2019/08/25/CF1204C-Anna-Svyatoslav-and-Maps-解题报告/"},{"title":"CF467D Fedor and Essay 解题报告","text":"字符串太菜了。 题目链接(Luogu) CF467D Fedor and Essay 题意简述给你一篇文章和n对单词，可以将文中的单词按对应对换。 求对换后文章含字母’r’的最小数量，以及此时文章中所有单词长度之和的最小值。 解题思想单词可以看成点，然后每个单词含’r’的数量可以理解为其点权。 我们按对应关系建图后，对该图缩点，然后每个节点跑一遍树形DP，统计一下自底向上统计最小值。 懒得写哈希了，所以用了map。没想到已经是最优解了。 用哈希理论上会跑更快，但是出题人可能闲得无聊构造了哈希冲突 对于文章长度最小值，我们可以在DP时判一下两个DP值相等的情况，然后取$\\min$就行了。 设$minn1[i]$为对应图上到单词$i$为止所有单词’r’的最小值，$minn2[i]$为对应图上到单词$i$位置符合题目条件的文章长度的最小值。 那么两个答案分别为：$ans_1 = \\sum\\limits_{1\\le i\\le n} minn1[scc[i]], ans_2 = \\sum\\limits_{1\\le i\\le n}minn2[scc[i]]$ 要开long long 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;std::map &lt;std::string, int&gt; mp;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(long long x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(long long x) { _write(x); putchar(' '); }}using namespace FastIO;const int N = 3e5 + 6;const int M = N &lt;&lt; 2;template &lt;typename T&gt; inline T min(T a, T b) {return a &lt; b ? a : b;}template &lt;typename T&gt; inline T max(T a, T b) {return a &gt; b ? a : b;}char ch[M];long long ans1, ans2;int n, m, sz;int ver[N], nxt[M], head[M], cnt, Cnt;int Ver[N], Nxt[M], Head[M];int scc[N], dfn[N], low[N], idx, tot;int sta[N], stop;int id[N], num[N], len[N];int minn1[N], minn2[N];bool v[N], vis[N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}inline void Add(int x, int y) { Ver[++cnt] = y, Nxt[cnt] = Head[x], Head[x] = cnt;}void tarjan(int x) { dfn[x] = low[x] = ++idx; v[x] = 1; sta[++stop] = x; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); } else if(v[y]) { low[x] = min(low[x], dfn[y]); } } int now = 0; if(low[x] == dfn[x]) { tot++; while(now != x) { now = sta[stop--]; v[now] = 0; scc[now] = tot; if(num[now] &lt; minn1[tot] || (num[now] == minn1[tot] &amp;&amp; len[now] &lt; minn2[tot])) { minn1[tot] = num[now], minn2[tot] = len[now]; } } }}inline void rebuild() { cnt = 0; for(register int x = 1; x &lt;= sz; x++) { for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(scc[x] != scc[y]) Add(scc[x], scc[y]); } }}void dp(int x) { if(vis[x]) return; vis[x] = 1; for(register int i = Head[x]; i; i = Nxt[i]) { int y = Ver[i]; dp(y); if(minn1[y] &lt; minn1[x]) { minn1[x] = minn1[y]; minn2[x] = minn2[y]; } else if(minn1[y] == minn1[x]) { minn2[x] = min(minn2[x], minn2[y]); } }}int main() { n = read(); for(register int i = 1; i &lt;= n; i++) { scanf(\"%s\", ch); int l = strlen(ch), k = 0; for(register int j = 0; j &lt; l; j++) { if(ch[j] &gt;= 'A' &amp;&amp; ch[j] &lt;= 'Z') ch[j] = ch[j] - 'A' + 'a'; if(ch[j] == 'r') k++; } int t = mp[ch]; if(!t) t = mp[ch] = ++sz; len[t] = l; num[t] = k; id[i] = t; } m = read(); for(register int i = 1; i &lt;= m; i++) { scanf(\"%s\", ch); int l = strlen(ch), k = 0; for(register int j = 0; j &lt; l; j++) { if(ch[j] &gt;= 'A' &amp;&amp; ch[j] &lt;= 'Z') ch[j] = ch[j] - 'A' + 'a'; if(ch[j] == 'r') k++; } int x = mp[ch]; if(!x) x = mp[ch] = ++sz; len[x] = l; num[x] = k; scanf(\"%s\", ch); l = strlen(ch), k = 0; for(register int j = 0; j &lt; l; j++) { if(ch[j] &gt;= 'A' &amp;&amp; ch[j] &lt;= 'Z') ch[j] = ch[j] - 'A' + 'a'; if(ch[j] == 'r') k++; } int y = mp[ch]; if(!y) y = mp[ch] = ++sz; len[y] = l; num[y] = k; add(x, y); } memset(minn1, 0x3f, sizeof(minn1)); memset(minn2, 0x3f, sizeof(minn2)); for(register int i = 1; i &lt;= sz; i++) if(!dfn[i]) tarjan(i); rebuild(); for(register int i = 1; i &lt;= tot; i++) dp(i); for(register int i = 1; i &lt;= n; i++) { ans1 += minn1[scc[id[i]]]; ans2 += minn2[scc[id[i]]]; } write(ans1); write(ans2); return 0;}","link":"/2019/08/02/CF467D-Fedor-and-Essay-解题报告/"},{"title":"HBTSC 2019 爆零记","text":"占坑，稳坐rk inf。 已更新,待补图。 Day 0起床起早了，头疼死。 上火车以为自己没带身份证，去办了个临时身份证，结果取票机不能用，自动检票不能用，麻烦的一批。 还拿到了两张WA色的票： 在四号候车口遇到了wjyyy，拿到了个人承诺书。 发现上面有什么不得了的东西： 接受特殊情况下的测试数据修改 … 爆蛋预定。 上了火车，在第一排差评，电脑只能放腿上。 复习了一下Tarjan板子，看了一下DFT，发现我的DFT是$O(n\\log n)$的，就去问wjy大爷： 自己貌似把FFT当DFT推了… 中午依旧KFC麦当劳。 然后就坐地铁去华科啦…潘老师似乎忘了我有武汉通，又给我买了单程票… 下地铁，武汉出奇的热。 成功在七天大厅面基到了款克爷。 聊了一会回房间休息去了。 下午是大型试(面)机(基)现场。 没有照片。 键盘比去年那个打的舒服，稍微有点不适应。 有vmware和vscode，比linux选手不知道赚到哪去。 继续复习缩点，第一遍各种问题，取顶不弹栈，取首不出队，加边不加度还试图毁原图缩点不过最后弃了 面基到了xls，头像与真人严重不符差评 （南一楼的天空） 然后就差不多六点了，去吃饭。 吃的烤鱼，烤鱼和水煮鱼味道完全不一样的说，我以前从不吃鱼的说 吃完跟wls和yls去找款克玩耍，上去之后他们却下来了： 等了一会款克上来了，但是没房卡，我手机快没电了于是上来了。 码了博客，洗了洗，准备睡。 明天加油吧。 Day 1上午七点多醒了，洗脸时接到了潘老师的电话，说是七点半进考场，有点慌，赶紧出门。 等电梯时看到电梯在12楼，就走了下去，结果到12楼了电梯却下8楼了，但是在楼梯口遇到了Quank。 本来准备买包子吃，在小卖部看到没有鸡腿肉馅的包子了，就买了个巧克力然后去隔壁的沙县小吃吃饭。 吃完去华科，找了半天没找到门，只能跟着（貌似是华一的）大部队上楼。 在非正式爆蛋选手处领了座位号。 上楼，等到了xht，问他借了一支笔。 进考场后突然发现那一排那一列好像都只有我一个人，看来好多人都报名没考。 开机，发现电脑上没有压缩包，马上去找了监考老师。 然后他居然把胶带撕了插u盘拷了一份… 解压密码不知道什么时候展示的，我开包的时候貌似还有很多人没看到… 看了一眼T1，感觉能枚举断点，就上手打了dfs。 大概一个小时不到，打完了，手玩了几组数据，没什么问题，就看t2. 没什么思路，想hash，hash不出来。就准备打#4，打了100+行后发现一样的套路貌似可以打#1，又上手写#1， 打完花了大概两个小时吧，#1没拍，不知道对不对。 看T3，以为是某集训队爷湖策出的丢失的题面。 点开测试数据发现貌似不太对劲。 #1以为是什么递推数列，要用矩阵快速幂玩，但是没看出来递推公式。 后面的字符串也没看太懂，就弃了。 回去优化T1。 想了个$O(n^4)$的DP，发现跑的好像比枚举断点还慢，就没改。加了个快读。 T2依然没有什么思路，一上午就过完了。 中午吃饭的路上，跟wjyyy聊天，突然发现自己T1题意看错了。 应该有小部分分吧 我只能这样安慰自己。 T2的#4的复杂度也被dew证实是错的。 Day1 30了…. 没有很伤心，去吃饭了。 下午讲题，公布成绩。 看到自己又爆蛋了，非常难受，T1评讲也没怎么听。 就在那翻那个人电脑上的文件。 突然看到他的考号文件夹里有三个题目名字的文件夹。 要建这玩意嘛？ 我问wjyyy。 要 于是懂了自己爆蛋的原因，甚至自己NOIP爆蛋的原因。 很难受，回房间了。 跟KSkun聊了一会，了解了一下优敏思，有点心动，寻思着暑假找个学校去学一学。 然后就睡觉去了。 Day 2早上醒来一看外面很亮，以为自己迟到了，结果一看手机才6：30…… 下楼去买早饭，没看到Quank。 在商店买了两包脆香米和一瓶咖啡，吃的和Day 1一样。 吃完就去华科了。 在南一楼门口遇到了苏老师。 连她都知道我Day 1爆蛋了 没聊几句就去排队了。 抽到了第二排。 上楼，进机房后直接点开压缩包，把三个题目文件夹建了。 看名字就觉得那个Hope不可做 密码依旧是脸滚键盘。 开包后先看T1，怎么是组合计数啊，没什么思路，打了10pts的暴力。 看T2，一副可做的样子，就开始想2000以内的点。 想了个贪心，瞎写了个类似二维堆的东西，本来用的priority_queue，死活不能嵌套，就换成了节点内建堆，外排序。打完快11:00了，只测了样例1，过了就去看T3了。 怎么又是组合计数啊……果然奶中了。 本来准备打链的暴力，结果不会，别的也想不出来，就弃了又去看T1。 T1也没什么思路，把T2稍微改了一下就交了。 下楼时听说dew的贪心和我的一样，（但是后来出成绩他75我5）。 我的第一次省选就这么结束了，没爆蛋，还是比较难受，可能是因为Day 1吧。 下午的讲题也没去听，直接往火车站走，（虽然还是差点迟到。 在火车上又调了一会春节十二响，没调出来，就到了。 这次省选，最大的收获可能就是会永远记住开文件夹吧…. Day inf被whk折磨的死去活来","link":"/2019/03/14/HBTSC-2018-爆零记/"},{"title":"Luogu P1073 最优贸易 解题报告","text":"发一个自认为代码比较好看的双向SPFA 题目链接思路先正图跑一遍SPFA维护每个点对于采购价的最小值。 在数据读入时存反图，以$s$点为源点，再次跑一遍SPFA维护每个点对于卖出价的最小值。 根据题意描述，在存图的时候要注意判断是否为无向边。 要注意本题是点权而不是边权。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using std::queue;using std::min;using std::max;const int N = 1e5+6;const int M = 5e5+6;int head1[N], next1[M], ver1[M];int head2[N], next2[M], ver2[M];int cnt1 = 0, cnt2 = 0;int a[N];int d1[N], v1[N], d2[N], v2[N];int n, m;inline void add1(int x, int y) { ver1[++cnt1] = y, next1[cnt1] = head1[x], head1[x] = cnt1;}inline void add2(int x, int y) { ver2[++cnt2] = y, next2[cnt2] = head2[x], head2[x] = cnt2;}//最小值 inline void spfa1() { queue&lt;int&gt; q1; memset(v1,0,sizeof(v1)); memset(d1,0x3f,sizeof(d1)); v1[1] = 1, d1[1] = a[1]; q1.push(1); while(!q1.empty()) { int x = q1.front(); q1.pop(); v1[x] = 0; for(register int i = head1[x] ; i ; i = next1[i]) { int y = ver1[i]; if(d1[y] &gt; min(d1[x], a[y])) { d1[y] = min(d1[x], a[y]); if(!v1[y]) q1.push(y), v1[y] = 1; } } }}//最大值 inline void spfa2() { queue&lt;int&gt; q2; memset(v2,0,sizeof(v2)); memset(d2,0,sizeof(d2)); v2[n] = 1, d2[n] = a[n]; q2.push(n); while(!q2.empty()) { int x = q2.front(); q2.pop(); v2[x] = 0; for(register int i = head2[x] ; i ; i = next2[i]) { int y = ver2[i]; if(d2[y] &lt; max(d2[x], a[y])) { d2[y] = max(d2[x], a[y]); if(!v2[y]) q2.push(y), v2[y] = 1; } } }}int main() { scanf(\"%d%d\",&amp;n,&amp;m); for(register int i = 1 ; i &lt;= n ; i++) scanf(\"%d\",&amp;a[i]); for(register int i = 1 ; i &lt;= m ; i++) { int x, y, opt; scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;opt); if(opt == 1) { add1(x,y); add2(y,x); } if(opt == 2) { add1(x,y); add1(y,x); add2(x,y); add2(y,x); } } spfa1(); spfa2(); int ans = 0; for(register int i = 1; i &lt;= n; i++) { ans = max(ans,d2[i] - d1[i]); } printf(\"%d\",ans); return 0;}","link":"/2019/03/21/Luogu-P1073-最优贸易-解题报告/"},{"title":"Luogu P1373 小a和uim之大逃离 解题报告","text":"题目链接P1373 小a和uim之大逃离 题意简述感觉题目描述挺清楚的 给定矩阵，两个人以任意点为起点，每次可以向下走或向右走，同时两人的得分交替加上当前格的值并对$k + 1$取模，可以在任意点由后者结束。求两人得分一致的方法数。 解题思想题目中的方案数与两人的具体得分无关，故我们考虑将每一步两人的差值作为状态。剩下的状态显而易见：当前位置和取数人。即$dp[x][y][\\Delta][op]$表示在坐标为$(x, y)$的方格上由$op$取数，取完后两人的差值为$\\Delta$ 因为由后者结束，所以我们只统计$op = 0$时的答案，并累加。再加上题目中给出的移动方式，我们不难得出状态转移方程： $$dp[x][y][\\Delta][0] = dp[x - 1][y][\\Delta - a[x][y]][1] + dp[x][y - 1][\\Delta - a[x][y]][1]$$ $$dp[x][y][\\Delta][1] = dp[x - 1][y][\\Delta + a[x][y]][0] + dp[x][y - 1][\\Delta + a[x][y]][0]$$ 需要考虑差值小于0的情况，这时将插值替代为模$k + 1$意义下的等价元就行了。 参考代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;const int N = 801;const int MOD = 1000000007;int n, m, k, ans;int a[N][N];int dp[N][N][17][2];int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); k++; for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= m; j++) { scanf(\"%d\", &amp;a[i][j]); dp[i][j][a[i][j] % k][0] = 1; } } for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= m; j++) { for(register int del = 0; del &lt;= k; del++) { dp[i][j][del][0] = (dp[i][j][del][0] + dp[i - 1][j][(del - a[i][j] + k) % k][1]) % MOD; dp[i][j][del][0] = (dp[i][j][del][0] + dp[i][j - 1][(del - a[i][j] + k) % k][1]) % MOD; dp[i][j][del][1] = (dp[i][j][del][1] + dp[i - 1][j][(del + a[i][j] + k) % k][0]) % MOD; dp[i][j][del][1] = (dp[i][j][del][1] + dp[i][j - 1][(del + a[i][j] + k) % k][0]) % MOD; } } } for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= m; j++) { ans = (ans + dp[i][j][0][1]) % MOD; } } printf(\"%d\", ans); return 0;}","link":"/2019/06/11/Luogu-P1373-小a和uim之大逃离-解题报告/"},{"title":"Luogu P1396 营救 解题报告","text":"题意简述给你一张图，有边权，求使得源点汇点联通的路径中边最大值的最小值。（貌似还是不很清楚） 思想看到最大的最小很多人想到二分，但是可以有更好的解法。我们不妨用并查集维护这个图，将边从小到大排序，每次取出边权最小的边，若该边的起点与终点未在一个集合内，就将其合并。当源点与汇点在一个集合内时，当前边的权值就是答案。 并查集基本操作这里有一个比较优美的路径压缩的实现： 1int find(int x) {return fa[x] = fa[x] == x ? x : find(fa[x]);} 一行代码。合并的话在主函数内直接写就行了，没有一些附加消息没必要单独写函数。 Code40行代码（有快读） 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;inline int read() { char ch = getchar(); int r = 0; while(!isdigit(ch)) ch = getchar(); while(isdigit(ch)) r = r * 10 + ch - '0', ch = getchar(); return r;}const int N = 20020;struct edge { int x, y, z;} e[N];int fa[N];inline bool cmp(edge a, edge b) {return a.z &lt; b.z;}int find(int x) {return fa[x] = fa[x] == x ? x : find(fa[x]);}int main() { int n = read(), m = read(), s = read(), t = read(); for(register int i = 1; i &lt;= n; i++) fa[i] = i; for(register int i = 1; i &lt;= m; i++) { int x = read(), y = read(), z = read(); e[i] = (edge) {x, y, z}; } std::sort(e + 1, e + m + 1, cmp); for(register int i = 1; i &lt;= m; i++) { int x = find(e[i].x), y = find(e[i].y); if(x != y) fa[x] = y; if(find(s) == find(t)) { printf(\"%d\", e[i].z); return 0; } }}","link":"/2019/04/18/Luogu-P1396-营救-解题报告/"},{"title":"Luogu P1726 上白泽慧音 解题报告","text":"又双叒叕写挂了TarjanQAQ 题目链接P1726 上白泽慧音 题意简述给你一张有向图，求出最大的强连通子图，并输出字典序最小的一个。 解题思想emmmm挺裸的题。 只需要Tarjan求强连通分量就行了。 至于字典序的处理： 不妨在缩点时更新答案，然后从小到大枚举每个点，第一个所属强连通分量大小与答案相同的强连通分量就是字典序最小的那个。 这里是枚举的代码： 123456for(register int i = 1; i &lt;= n; i++) { if(scc[i] == ans) { ans = i; break; } } 输出答案： 123for(register int i = ans; i &lt;= n; i++) { if(scc[i] == scc[ans]) write(i);} 注意一下细节就好了。 至于写挂的Tarjan… 123456789101112if(low[x] == dfn[x]) { tot++; while(s.top()) { int y = s.top(); s.pop(); scc[y] = tot; v[y] = 0;//这里要清零！！！！！！！ num[tot]++; if(x == y) break; } if(num[tot] &gt; num[ans]) ans = tot;} v[]要清零…. 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0'; ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); putchar(' '); }}using namespace FastIO;const int N = 5010;const int M = 100010;template &lt;typename T&gt; T min(T a, T b) {return a &lt; b ? a : b;}template &lt;typename T&gt;class stack { private: int stop; T s[N]; public: stack() {stop = 0;} inline bool empty() {return !stop;} inline void push(T x) {s[++stop] = x;} inline void pop() {if(!empty()) stop--;} inline T top() {return s[stop];}};stack &lt;int&gt; s;int head[N], ver[M], nxt[M], scc[N], num[N], dfn[N], low[N];int cnt, idx, tot, ans, n, m;bool v[N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}void tarjan(int x) { dfn[x] = low[x] = ++idx; s.push(x); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); } else if(v[y]) { low[x] = min(low[x], dfn[y]); } } if(low[x] == dfn[x]) { tot++; while(s.top()) { int y = s.top(); s.pop(); scc[y] = tot; v[y] = 0; num[tot]++; if(x == y) break; } if(num[tot] &gt; num[ans]) ans = tot; }}int main() { n = read(), m = read(); for(register int i = 1; i &lt;= m; i++) { int x = read(), y = read(), opt = read(); add(x, y); if(opt == 2) add(y, x); } for(register int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } printf(\"%d\\n\", num[ans]); for(register int i = 1; i &lt;= n; i++) { if(scc[i] == ans) { ans = i; break; } } for(register int i = ans; i &lt;= n; i++) { if(scc[i] == scc[ans]) write(i); } return 0;}","link":"/2019/05/02/Luogu-P1726-上白泽慧音-解题报告/"},{"title":"Luogu P1967 货车运输 解题报告","text":"卡空间的屑题 题目链接P1967 货车运输 题意简述给你一个图，有边权，对于任意一组询问，输出给定两点间所有路径中边权的最小值的最大值。（即题意中限重的最大值） 解题思想跟二分没关系啊，考虑构造图的最大生成树，这样可以满足最大值这一条件。 此时，两点间的路径有且仅有一条： $$E(x,y) = E(x, lca(x,y)) + E(lca(x, y), y)$$ 在树上倍增的时候口胡倍增优化DP维护$min{W(x, lca(x,y))}$和$min{W(lca(x,y)), y)}$, 答案取$min$就行了。 需要注意的是查询的两点不一定联通，所以我们在Kruskal构造最大生成树的同时可以维护图上两点的连通性，查询时加入判断就行了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;using namespace std;const int N = 100010;const int M = 400010;inline void fileread() { freopen(\"a.in\", \"r\", stdin); freopen(\"a.out\",\"w\",stdout);}struct Edge { int x, y, z;}e[N];int fa[N];int head[N], edge[M], ver[M], nxt[M], cnt;int lg[N], f[N][22], w[N][22], d[N];int n, m, q;bool v[N];inline void add(int x, int y, int z) { ver[++cnt] = y, edge[cnt] = z, nxt[cnt] = head[x], head[x] = cnt;}inline bool cmp(Edge a, Edge b) { return a.z &gt; b.z;}inline void init() { for(register int i = 1; i &lt;= n; i++) { fa[i] = i; lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i); d[i] = 1; }}int find(int x) {return fa[x] = fa[x] == x ? x : find(fa[x]);}inline bool merge(int x, int y) { int xx = find(x), yy = find(y); if(xx == yy) return 0; fa[xx] = yy; return 1;}inline void rebuild() { sort(e + 1, e + m + 1, cmp); int tot = 0; init(); for(register int i = 1; i &lt;= m; i++) { int x = e[i].x, y = e[i].y, z = e[i].z; if(merge(x, y)) { tot++; add(x, y, z); add(y, x, z); if(tot == n - 1) return; } }}void dfs(int x) { v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(!v[y]) { d[y] = d[x] + 1; f[y][0] = x; w[y][0] = z; dfs(y); } }}inline int lca(int x, int y) { if(find(x) != find(y)) return -1; int ans = 0x3f3f3f3f; if(d[y] &gt; d[x]) swap(x, y); for(register int i=20; i&gt;=0; i--) { if(d[f[x][i]]&gt;=d[y]){ ans = min(ans, w[x][i]); x = f[x][i]; } } if(x == y) return ans; for(register int i = lg[d[x]]; i &gt;= 0; i--) { if(f[x][i] != f[y][i]) { ans = min(ans, min(w[x][i], w[y][i])); x = f[x][i], y = f[y][i]; } } ans = min(ans, min(w[x][0], w[y][0])); return ans;}int main() { n = read(), m = read(); for(register int i = 1; i &lt;= m; i++) { e[i].x = read(), e[i].y = read(), e[i].z = read(); } rebuild(); for(register int i = 1; i &lt;= n; i++) { if(!v[i]) { d[i] = 1; dfs(i); f[i][0] = i; w[i][0] = 0x3f3f3f3f; } } for(register int i = 1; i &lt;= 20; i++) { for(register int j = 1; j &lt;= n; j++) { f[j][i] = f[f[j][i - 1]][i - 1]; w[j][i] = min(w[j][i - 1], w[f[j][i - 1]][i - 1]); } } q = read(); for(register int i = 1; i &lt;= q; i++) { int x = read(), y = read(); write(lca(x, y)); } return 0;}","link":"/2019/04/29/Luogu-P1967-货车运输/"},{"title":"Luogu P2146 [NOI2015]软件包管理器 解题报告","text":"这是wjyyy嗦的$\\uparrow$ 题目链接P2146 [NOI2015]软件包管理器 题意简述给你一棵树，有点权。将点权赋值为1需要将根到该点路径上所有点赋值为，将点权赋值为0会使以该点为根的子树上的所有点点权变为0。初始时所有点点权为0，给你m个赋值操作，输出每个操作会改变多少个点的状态。 解题思想发现树的形态没有改变，我们考虑树剖。然后求出根到某个点的链的长度和某个点的子树大小，线段树维护即可。 但是我们发现这里面是区间赋值操作，而不是区间增加操作，如果单个点做效率极低，我们考虑一种新的线段树： 区间覆盖线段树我们考虑在区间增线段树的基础上将增加改成赋值。 于是我们将tag[]维护的信息由增量改为赋值数，发现根据时间的先后，这个信息会被逐步替代，于是就可以在下放的时候直接用父节点标记盖住子节点标记，即把+=改为=。这样就可以整个区间赋值为同一个数。 注意一下题目中有赋值为0的操作，所以tag[]的初值不能为0，否则就会出锅。（卡了我一下午 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 100010;const int M = N &lt;&lt; 1;template &lt;typename T&gt; inline void swap(T &amp;x, T &amp;y) {T tmp = x; x = y, y = tmp;}template &lt;typename T&gt; inline T min(T a, T b) {return a &lt; b ? a : b;}template &lt;typename T&gt; inline T max(T a, T b) {return a &gt; b ? a : b;}int n, q, w[N];int head[N], nxt[M], ver[M], cnt, idx;int d[N], sz[N], fa[N], tp[N], son[N];int dfn[N], ptn[N];int val[N &lt;&lt; 2], tag[N &lt;&lt; 2];#define ls (o &lt;&lt; 1)#define rs (o &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)inline void upd(int o) { val[o] = val[ls] + val[rs];}inline void pushdown(int o, int l, int r) { if(tag[o] != -1) { tag[ls] = tag[o]; tag[rs] = tag[o]; val[ls] = tag[o] * (mid - l + 1); val[rs] = tag[o] * (r - mid); } tag[o] = -1;}void build(int o, int l, int r) { if(l == r) {val[o] = w[ptn[l]]; return;} build(ls, l, mid); build(rs, mid + 1, r); upd(o);}void modify(int o, int l, int r, int ll, int rr, int k) { if(l &gt;= ll &amp;&amp; r &lt;= rr) { val[o] = k * (r - l + 1); tag[o] = k; return; } pushdown(o, l, r); if(ll &lt;= mid) modify(ls, l, mid, ll, rr, k); if(rr &gt; mid) modify(rs, mid + 1, r, ll, rr, k); upd(o);}int query(int o, int l, int r, int ll, int rr) { if(l &gt;= ll &amp;&amp; r &lt;= rr) return val[o]; pushdown(o, l, r); int res = 0; if(ll &lt;= mid) res += query(ls, l, mid, ll, rr); if(rr &gt; mid) res += query(rs, mid + 1, r, ll, rr); return res;}void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt; ver[++cnt] = x, nxt[cnt] = head[y], head[y] = cnt;}void dfs1(int x) { sz[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x]) continue; fa[y] = x; d[y] = d[x] + 1; dfs1(y); sz[x] += sz[y]; if(sz[y] &gt; sz[son[x]]) son[x] = y; }}void dfs2(int x, int top) { tp[x] = top; dfn[x] = ++idx; ptn[idx] = x; if(son[x]) dfs2(son[x], top); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x] || y == son[x]) continue; dfs2(y, y); }}inline void changeline(int x, int y, int z) { while(tp[x] != tp[y]) { if(d[tp[x]] &gt; d[tp[y]]) swap(x, y); modify(1, 1, n, dfn[tp[y]], dfn[y], z); y = fa[tp[y]]; } if(d[x] &gt; d[y]) swap(x, y); modify(1, 1, n, dfn[x], dfn[y], z);}inline int queryline(int x, int y) { int res = 0; while(tp[x] != tp[y]) { if(d[tp[x]] &gt; d[tp[y]]) swap(x, y); res += query(1, 1, n, dfn[tp[y]], dfn[y]); y = fa[tp[y]]; } if(d[x] &gt; d[y]) swap(x, y); res += query(1, 1, n, dfn[x], dfn[y]); return res;}inline void changetree(int x, int z) { modify(1, 1, n, dfn[x], dfn[x] + sz[x] - 1, z);}inline int querytree(int x) { return query(1, 1, n, dfn[x], dfn[x] + sz[x] - 1);}char s[10];int main() { memset(tag, -1, sizeof(tag)); n = read(); for(register int i = 2; i &lt;= n; i++) { add(read() + 1, i); } dfs1(1); dfs2(1, 1); build(1, 1, n); q = read(); for(register int i = 1; i &lt;= q; i++) { scanf(\"%s\", s); register int x = read() + 1; int num = val[1]; if(s[0] == 'i') { changeline(1, x, 1); write(val[1] - num); } else { changetree(x, 0); write(num - val[1]); } } return 0;}","link":"/2019/07/17/Luogu-P2146-NOI2015-软件包管理器-解题报告/"},{"title":"Luogu P2153 [SDOI2009]晨跑 解题报告","text":"老是这种套路就没意思了。 题目链接P2153 [SDOI2009]晨跑 题意简述求给定网络的最大流与最小费用，其中每个点仅允许经过一次。 解题思想看到限制，考虑拆点。 不妨将每个点拆成$i$和$i + n$两个点，在中间连接一条流量为1的边，并且点$i$出度为1，点$i + n$入度为1. 这样可以限制点的经过次数。 然后在新图中以$1 + n$为原点，$n$为汇点跑EK+SPFA就行了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) r = r * 10 + ch - '0' , ch = getchar(); return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); putchar(' '); }}using namespace FastIO;const int N = 10006;const int M = 2000006;const int INF = 0x3f3f3f3f;template &lt;typename T&gt; T min(T a, T b) {return a &lt; b ? a : b;}template &lt;typename T&gt;class queue { private: int head, tail; T q[N &lt;&lt; 1]; public: queue() {head = tail = 0;} inline bool empty() {return head &gt;= tail;} inline void push(T x) {q[++tail] = x;} inline void pop() {if(!empty()) head++;} inline T front() {return q[head + 1];}};int head[N], ver[M], edge[M], cost[M], nxt[M], pre[N], incf[N], d[N];int cnt = 1, n, m, s, t, maxflow, mincost;bool v[N];inline void add(int x, int y, int z, int w) { ver[++cnt] = y, edge[cnt] = z, cost[cnt] = w, nxt[cnt] = head[x], head[x] = cnt; ver[++cnt] = x, edge[cnt] = 0, cost[cnt] = -w, nxt[cnt] = head[y], head[y] = cnt;}inline bool spfa() { for(register int i = 1; i &lt;= n &lt;&lt; 1; i++) v[i] = 0, d[i] = INF; queue &lt;int&gt; q; q.push(s); d[s] = 0; v[s] = 1; incf[s] = INF; while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 0; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i], w = cost[i]; if(!z) continue; if(d[y] &gt; d[x] + w) { d[y] = d[x] + w; incf[y] = min(incf[x], z); pre[y] = i; if(!v[y]) { v[y] = 1; q.push(y); } } } } return d[t] != INF;}inline void upd() { maxflow += incf[t]; mincost += incf[t] * d[t]; int x = t; while(x != s) { int i = pre[x]; edge[i] -= incf[t]; edge[i ^ 1] += incf[t]; x = ver[i ^ 1]; }}int main() { n = read(), m = read(); for(register int i = 1; i &lt;= m; i++) { int x = read(), y = read(), z = read(); add(x + n, y, 1, z); } for(register int i = 1; i &lt;= n; i++) { add(i, i + n, 1, 0); } s = 1 + n, t = n; while(spfa()) upd(); write(maxflow); write(mincost); return 0;} 为什么我的数组总是开小啊QAQ","link":"/2019/04/30/Luogu-P2153-SDOI2009-晨跑-解题报告/"},{"title":"Luogu P2272 [ZJOI2007]最大半联通子图 解题报告","text":"题面成那样了都没人管….也是服 NOI Linux 真好用 题目链接P2272 [ZJOI2007]最大半连通子图 题意简述最大半联通子图计数。 解题思想联通子图缩点后DP最长链，然后计数的话在SCC上DP的时候记录一下相等的情况就行了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); putchar('\\n'); }}using namespace FastIO;const int N = 1e5 + 6;const int M = 2e6 + 6;template &lt;typename T&gt;class stack { private: int stop; T s[N]; public: stack() {stop = 0;} inline bool empty() {return stop == 0;} inline void push(T x) {s[++stop] = x;} inline void pop() {if(!empty()) stop--;} inline T top() {return s[stop];}};template &lt;typename T&gt;class queue { private: int head, tail; T q[N &lt;&lt; 1]; public: queue() {head = tail = 0;} inline bool empty() {return head &gt;= tail;} inline void push(T x) {q[++tail] = x;} inline void pop() {if(!empty()) head++;} inline T front() {return q[head + 1];}};stack &lt;int&gt; s;int n, m, mod;int head[N], nxt[M], ver[M], cnt;int scc[N], dfn[N], low[N], num[N], idx, tot;bool v[N];int Head[N], Nxt[M], Ver[M], pre[N], Cnt;int in[N], dp[N], ans[N];inline int min(int a, int b) {return a &lt; b ? a : b;}inline int max(int a, int b) {return a &gt; b ? a : b;}inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}void tarjan(int x) { dfn[x] = low[x] = ++idx; s.push(x); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); } else if(v[y]) low[x] = min(low[x], dfn[y]); } if(dfn[x] == low[x]) { tot++; while(!s.empty()) { int y = s.top(); s.pop(); v[y] = 0; scc[y] = tot; num[tot]++; if(x == y) break; } }}inline void Add(int x, int y) { Ver[++Cnt] = y, Nxt[Cnt] = Head[x], Head[x] = Cnt; in[y]++;}inline void rebuild() { for(register int x = 1; x &lt;= n; x++) { for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(scc[x] != scc[y]) Add(scc[x], scc[y]); } }}inline void TopSort() { queue &lt;int&gt; q; for(register int i = 1; i &lt;= tot; i++) { if(!in[i]) q.push(i); dp[i] = num[i], ans[i] = 1; } while(!q.empty()) { int x = q.front(); q.pop(); for(register int i = Head[x]; i; i = Nxt[i]) { int y = Ver[i]; in[y]--; if(!in[y]) q.push(y); if(pre[y] == x) continue; if(dp[y] &lt; dp[x] + num[y]) { dp[y] = dp[x] + num[y]; ans[y] = ans[x]; } else if(dp[y] == dp[x] + num[y]) { ans[y] = (ans[y] + ans[x]) % mod; } pre[y] = x; } }}int main() { n = read(), m = read(), mod = read(); for(register int i = 1; i &lt;= m; i++) add(read(), read()); for(register int i = 1; i &lt;= n; i++) if(!dfn[i]) tarjan(i); rebuild(); TopSort(); int count = 0, maxx = 0; for(register int i = 1; i &lt;= tot; i++) { if(dp[i] &gt; maxx) maxx = dp[i], count = ans[i]; else if(dp[i] == maxx) count = (count + ans[i]) % mod; } write(maxx); write(count); return 0;}","link":"/2019/08/01/Luogu-P2272-ZJOI2007-最大半联通子图-解题报告/"},{"title":"Luogu P2486 [SDOI2011]染色 解题报告","text":"傻逼题 题目链接P2486 [SDOI2011]染色 题意简述直接搬luogu了。 解题思想先树剖，线段树维护三个信息： 区间颜色数量 区间左端点颜色 区间右端点颜色 然后在合并的时候判一下两区间颜色是否重叠就行了。 做法一眼了，码了一万年。 难码，草。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define int unsigned intinline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w;}const int N = 100005;int n, m, w[N], ut, vt, at, bt, ct;char op;int fa[N], siz[N], son[N], dfn[N], ptn[N], top[N], dep[N], cnt;std::vector&lt;int&gt; gra[N];inline void add(int u, int v) { gra[u].push_back(v); gra[v].push_back(u);}void dfs1(int u) { for(int i = 0; i &lt; gra[u].size(); i++) { int v = gra[u][i]; if(v == fa[u]) continue; dep[v] = dep[u] + 1; fa[v] = u; dfs1(v); siz[u] += siz[v] + 1; if(siz[v] &gt; siz[son[u]]) son[u] = v; }}void dfs2(int u, int tp) { top[u] = tp; dfn[u] = ++cnt; ptn[dfn[u]] = u; if(son[u]) dfs2(son[u], tp); for(int i = 0; i &lt; gra[u].size(); i++) { int v = gra[u][i]; if(v == son[u] || v == fa[u]) continue; dfs2(v, v); }}struct Node { int l, r, tot; bool tag;} sgt[N &lt;&lt; 2];void pushdown(int o) { int lch = o &lt;&lt; 1, rch = (o &lt;&lt; 1) | 1; if(sgt[o].tag) { sgt[lch].l = sgt[lch].r = sgt[rch].l = sgt[rch].r = sgt[o].l; sgt[lch].tag = sgt[rch].tag = true; sgt[lch].tot = sgt[rch].tot = 1; sgt[o].tag = false; }}void merge(Node &amp;rt, Node ls, Node rs) { rt.l = ls.l; rt.r = rs.r; rt.tot = ls.tot + rs.tot; if(ls.r == rs.l) rt.tot--;}void build(int o, int l, int r) { if(l == r) { sgt[o].l = sgt[o].r = w[ptn[l]]; sgt[o].tot = 1; return; } int mid = (l + r) &gt;&gt; 1, lch = o &lt;&lt; 1, rch = (o &lt;&lt; 1) | 1; build(lch, l, mid); build(rch, mid + 1, r); merge(sgt[o], sgt[lch], sgt[rch]);}void modify(int o, int l, int r, int ll, int rr, int v) { if(l == ll &amp;&amp; r == rr) { sgt[o].l = sgt[o].r = v; sgt[o].tot = 1; sgt[o].tag = true; return; } pushdown(o); int mid = (l + r) &gt;&gt; 1, lch = o &lt;&lt; 1, rch = (o &lt;&lt; 1) | 1; if(rr &lt;= mid) { modify(lch, l, mid, ll, rr, v); } else if(ll &gt; mid) { modify(rch, mid + 1, r, ll, rr, v); } else { modify(lch, l, mid, ll, mid, v); modify(rch, mid + 1, r, mid + 1, rr, v); } merge(sgt[o], sgt[lch], sgt[rch]);}Node query(int o, int l, int r, int ll, int rr) { if(l == ll &amp;&amp; r == rr) { return sgt[o]; } pushdown(o); int mid = (l + r) &gt;&gt; 1, lch = o &lt;&lt; 1, rch = (o &lt;&lt; 1) | 1; if(rr &lt;= mid) { return query(lch, l, mid, ll, rr); } else if(ll &gt; mid) { return query(rch, mid + 1, r, ll, rr); } else { Node ls = query(lch, l, mid, ll, mid), rs = query(rch, mid + 1, r, mid + 1, rr), res; merge(res, ls, rs); return res; }}void modify(int u, int v, int c) { int tu = top[u], tv = top[v]; while(tu != tv) { if(dep[tu] &gt; dep[tv]) { std::swap(tu, tv); std::swap(u, v); } modify(1, 1, n, dfn[tv], dfn[v], c); v = fa[tv]; tv = top[v]; } if(dep[u] &gt; dep[v]) std::swap(u, v); modify(1, 1, n, dfn[u], dfn[v], c);}int query(int u, int v) { Node t; int res = 0, cu = -1, cv = -1, tu = top[u], tv = top[v]; while(tu != tv) { if(dep[tu] &gt; dep[tv]) { std::swap(tu, tv); std::swap(u, v); std::swap(cu, cv); } t = query(1, 1, n, dfn[tv], dfn[v]); res += t.tot; if(t.r == cv) res--; cv = t.l; v = fa[tv]; tv = top[v]; } if(dep[u] &gt; dep[v]) { std::swap(u, v); std::swap(cu, cv); } t = query(1, 1, n, dfn[u], dfn[v]); res += t.tot; if(t.l == cu) res--; if(t.r == cv) res--; return res;}signed main() { n = read(); m = read(); for(int i = 1; i &lt;= n; i++) w[i] = read(); for(int i = 1; i &lt; n; i++) { ut = read(); vt = read(); add(ut, vt); } dfs1(1); dfs2(1, 1); build(1, 1, n); while(m--) { do { op = getchar(); } while(op != 'C' &amp;&amp; op != 'Q'); at = read(); bt = read(); if(op == 'Q') { printf(\"%d\\n\", query(at, bt)); } if(op == 'C') { ct = read(); modify(at, bt, ct); } } return 0;}","link":"/2019/07/19/Luogu-P2486-SDOI2011-染色-解题报告/"},{"title":"Luogu P2886 [USACO07NOV]牛继电器Cow Relays 解题报告","text":"矩乘x图论 题目描述极其不清楚差评。 题目链接P2886 [USACO07NOV]牛继电器Cow Relays 题意简述给定一张无向图，边号为T，求S-&gt;E的经过N条边的最短路。 解题思想看到边数可以想到使用Floyd，但是$n$过大，于是可以推测点编号分布稀疏，在读入时离散化一下。 如何维护经过的边数为N？考虑两个矩阵$A = x \\times x,B = y \\times y$分别维护了点数为$x, y$的最短路，我们将其合并，便可以得到一个点数为$x + y$的最短路矩阵。类似地，考虑将原距离矩阵合并$n - 1$次，我们便可以得到经过N条边的最短路。 但是观察题目中的$N$的范围，我们发现：太大了。又注意到每次合并的矩阵相同，都为原距离矩阵，不妨考虑矩阵快速幂，但是重载的乘法需要改为合并的更新操作而不是一般意义下的矩阵乘法，这样，就可以$O(\\log n)$得到答案。 可以叫它广义矩阵快速幂嘛QAQ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#define add(x, y, z) d.m[x][y] = z;const int N = 1000010;template &lt;typename T&gt; T min(T a, T b) {return a &lt; b ? a : b;}int n, t, s, e, tot;int num[N];struct Mat { int m[501][501]; Mat operator * (const Mat &amp;a) const { Mat ans; memset(ans.m, 0x3f, sizeof(ans.m)); for(register int k = 1; k &lt;= tot; k++) { for(register int i = 1; i &lt;= tot; i++) { for(register int j = 1; j &lt;= tot; j++) { ans.m[i][j] = min(ans.m[i][j], m[i][k] + a.m[k][j]); } } } return ans; }}f, d;int main() { memset(d.m, 0x3f, sizeof(d.m)); scanf(\"%d %d %d %d\", &amp;n, &amp;t, &amp;s, &amp;e); for(register int i = 1; i &lt;= t; i++) { int x, y, z; scanf(\"%d%d%d\", &amp;z, &amp;x, &amp;y); if(!num[x]) num[x] = ++tot; if(!num[y]) num[y] = ++tot; add(num[x], num[y], z); add(num[y], num[x], z); } f = d; n--; for(; n; n &gt;&gt;= 1, d = d * d) if(n &amp; 1) f = f * d; printf(\"%d\", f.m[num[s]][num[e]]); return 0;}","link":"/2019/05/14/Luogu-P2886-USACO07NOV-牛继电器Cow-Relays-解题报告/"},{"title":"Luogu P2746 [USACO5.3]校园网Network of Schools 解题报告","text":"for(register int j = 1; j &lt;= n; i++) Farmer John太屑了 题目链接P2746 [USACO5.3]校园网Network of Schools 题意简述给你一张图，你得看出来题目让你找出入度为0的强连通分量的个数以及它与出度为0的强连通分量的个数较大者 解题思想先来解读一下为什么要向题意简述那样做： 第一问要想分发给更多的学校，必须从入度为0的点开始分发。 不妨考虑一个入度不为0的点：对于一个入度不为0的点，我们总能从可以抵达它的点开始分发，这样接收数量显然更优。 第二问要使原图强连通，则构造后的图不存在入度与出度为0的点。我们仅需求出两者中的数量较大者， 可以通过较小者向其连较大数量的边使原图不存在入度与出度为0的点，此时原图强连通。 具体实现就是缩点后统计一下每个节点的度就行了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0'; ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}const int N = 110;const int M = N * N;using namespace FastIO;template &lt;typename T&gt; T max(T a, T b) {return a &gt; b ? a : b;}template &lt;typename T&gt; T min(T a, T b) {return a &lt; b ? a : b;}template &lt;typename T&gt;class stack { private: int stop; T s[N &lt;&lt; 1]; public: stack() {stop = 0;} inline bool empty() {return !stop;} inline void push(T x) {s[++stop] = x;} inline void pop() {if(!empty()) stop--;} inline T top() {return s[stop];}};stack &lt;int&gt; s;int head[N], ver[M], nxt[M], scc[N], dfn[N], low[N];int in[N], out[N];int idx, cnt, ans1, ans2, n, tot;bool v[N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}void tarjan(int x) { dfn[x] = low[x] = ++idx; v[x] = 1; s.push(x); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); } else if(v[y]) { low[x] = min(low[x], dfn[y]); } } if(dfn[x] == low[x]) { tot++; while(s.top()) { int y = s.top(); s.pop(); v[y] = 0; scc[y] = tot; if(x == y) break; } }}int main() { n = read(); for(register int i = 1; i &lt;= n; i++) { int x = read(); while(x != 0) add(i, x), x = read(); } for(register int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(register int i = n; i &gt;= 1; i--) { for(register int j = head[i]; j; j = nxt[j]) { if(scc[i] != scc[ver[j]]) { in[scc[ver[j]]]++; out[scc[i]]++; } } } for(register int i = 1; i &lt;= tot; i++) { if(in[i] == 0) ans1++; if(out[i] == 0) ans2++; } if(tot == 1) { puts(\"1\"); puts(\"0\"); return 0; } write(ans1); write(max(ans1, ans2)); return 0;}","link":"/2019/04/30/Luogu-P2746-USACO5-3-校园网Network-of-Schools-解题报告/"},{"title":"Luogu P3119 草鉴定 解题报告","text":"草鉴定太艹了。 题目链接P3119 草鉴定Grass Cownoisseur 题意简述给你一张图，允许加一条已知边的反向边，求从点1出发并回到点1最多经过多少个点。 解题思想首先在原图上缩点，缩成DAG，点权相加。 然后在DAG上拓扑排序或者SPFA求出以1为源的最长路。 然后建反图（可以在缩点后就搞）。 再在反图上求出以scc[1]为源的最长路，即原DAG上以scc[1]为汇的最长路。 最后，枚举每一个原图上的顶点i，若scc[i]可达，枚举每一条反向边，同时更新答案。 注意反向边未使用的情况，初始化ans = num[scc[1]]就行了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'); if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 1e5 + 6;const int M = N &lt;&lt; 1;const int INF = 0xcfcfcfcf;template &lt;typename T&gt; T max(T a, T b) {return a &gt; b ? a : b;}template &lt;typename T&gt; T min(T a, T b) {return a &lt; b ? a : b;}template &lt;typename T&gt;class stack { private: int stop; T s[N &lt;&lt; 1]; public: stack() {stop = 0;} inline bool empty() {return stop == 0;} inline void push(T x) {s[++stop] = x;} inline void pop() {if(!empty()) stop--;} inline T top() {return s[stop];}};template &lt;typename T&gt;class queue { private: int head, tail; T q[N &lt;&lt; 1]; public: queue() {head = tail = 0;} inline bool empty() {return head &gt;= tail;} inline void push(T x) {q[++tail] = x;} inline void pop() {if(!empty()) head++;} inline T front() {return q[head + 1];}};int n, m, st, ans;int head[N], ver[M], nxt[M], cnt;int dfn[N], low[N], scc[N], num[N], tot, idx;int head1[N], ver1[M], nxt1[M], cnt1;int head2[N], ver2[M], nxt2[M], cnt2;int d1[N], d2[N];bool v[N];stack &lt;int&gt; s;inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}inline void add1(int x, int y) { ver1[++cnt1] = y, nxt1[cnt1] = head1[x], head1[x] = cnt1;}inline void add2(int x, int y) { ver2[++cnt2] = y, nxt2[cnt2] = head2[x], head2[x] = cnt2;}void tarjan(int x) { dfn[x] = low[x] = ++idx; s.push(x); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); } else if(v[y]) { low[x] = min(low[x], dfn[y]); } } if(low[x] == dfn[x]) { tot++; while(s.top()) { int y = s.top(); s.pop(); scc[y] = tot; num[tot]++; v[y] = 0; if(x == y) break; } }}inline void spfa1() { queue &lt;int&gt; q; v[st] = 1; d1[st] = num[st]; q.push(st); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 0; for(register int i = head1[x]; i; i = nxt1[i]) { int y = ver1[i]; if(d1[y] &lt; d1[x] + num[y]) { d1[y] = d1[x] + num[y]; if(!v[y]) { v[y] = 1; q.push(y); } } } }}inline void spfa2() { queue &lt;int&gt; q; v[st] = 1; d2[st] = num[st]; q.push(st); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 0; for(register int i = head2[x]; i; i = nxt2[i]) { int y = ver2[i]; if(d2[y] &lt; d2[x] + num[y]) { d2[y] = d2[x] + num[y]; if(!v[y]) { v[y] = 1; q.push(y); } } } }}int main() { n = read(), m = read(); for(register int i = 1; i &lt;= m; i++) { add(read(), read()); } for(register int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } st = scc[1]; for(register int x = 1; x &lt;= n; x++) { for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(scc[x] != scc[y]) add1(scc[x], scc[y]), add2(scc[y], scc[x]); } } spfa1(); spfa2(); int ans = num[st]; for(register int x = 1; x &lt;= n; x++) { if(!v[scc[x]] &amp;&amp; d1[scc[x]]) { v[scc[x]] = 1; for(register int i = head2[scc[x]]; i; i = nxt2[i]) { int y = ver2[i]; if(!d2[y]) continue; ans = max(ans, d1[scc[x]] + d2[y] - num[st]); } } } write(ans); return 0;}","link":"/2019/05/04/Luogu-P3119-草鉴定-解题报告/"},{"title":"Luogu P3199 [HNOI2009]最小圈 解题报告","text":"是实域二分耶！ 题目链接P3199 [HNOI2009]最小圈 题意简述给你一张图，求每个环的边长平均值的最小值。 解题思想直接做不好做，看到极值考虑二分。 二分答案后，我们对每一条边减去这个答案，然后跑负环。如果有负环，说明答案可以更小，此题完结。 需要注意一下边权是浮点数，所以不管是答案还是dist[]数组都要开浮点型，不然会炸。 实域二分听说for(次数)比while() + eps更精确？没试。 还有边数莫名开小… 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w;}const int N = 6010;const int M = N &lt;&lt; 1;const double eps = 1e-10;const int INF = 1e7;int n, m, cnt;int head[N], nxt[M], ver[M];double edge[M], d[N];bool v[N];inline void add(int x, int y, double z) { ver[++cnt] = y, edge[cnt] = z, nxt[cnt] = head[x], head[x] = cnt;}inline void init() { memset(v, 0, sizeof(v)); memset(d, 0, sizeof(d));}bool dfs(int x, double ans) { v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(d[y] &gt; d[x] + z - ans - eps) { if(v[y]) return 1; d[y] = d[x] + z - ans; if(dfs(y, ans)) return 1; } } v[x] = 0; return 0;}inline bool check(double ans) { init(); for(register int i = 1; i &lt;= n; i++) { if(v[i]) continue; if(dfs(i, ans)) return 1; } return 0;}int main() { n = read(), m = read(); for(register int i = 1; i &lt;= m; i++) { int x = read(), y = read(); double z; scanf(\"%lf\", &amp;z); add(x, y, z); } double l = -INF, r = INF; while(r - l &gt; eps) { double mid = (l + r) / 2; if(check(mid)) r = mid; else l = mid; } printf(\"%.8lf\", r); return 0;}","link":"/2019/07/17/Luogu-P3199-HNOI2009-最小圈-解题报告/"},{"title":"Luogu P3258 [JLOI2014]松鼠的新家 解题报告","text":"线段树大常数选手怕被卡，所以写了树上差分qwq。 题目链接P3258 [JLOI2014]松鼠的新家 题意简述给你一棵树和一个遍历顺序，求每个点至少经过多少次。 解题思想树剖+线段树直接对每条链区间加1就可，板子题，两个log跑得快。 树剖+树上差分考虑只有链，还是加1，不妨用树上差分然而写这题之前我并不会，对于每条链，我们考虑维护一个到根距离的差分数组记为d[x]，这样的话，要对链$(x,y)$整体加一，只需d[x]++, d[y]++, d[fa[lca(x, y)]] -= 2，把祖先节点到根的距离容斥掉，即可完成对链的整体加1，少个log。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 3e5 + 6;const int M = N &lt;&lt; 1;template &lt;typename T&gt; inline void swap(T &amp;x, T &amp;y) {T tmp = x; x = y, y = tmp;}int n, delta[N];int head[N], nxt[M], ver[M], cnt;int w[N], a[N], dfn[N], ptn[N], idx;int tp[N], sz[N], d[N], fa[N], son[N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt; ver[++cnt] = x, nxt[cnt] = head[y], head[y] = cnt;}void dfs1(int x) { sz[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x]) continue; fa[y] = x; d[y] = d[x] + 1; dfs1(y); sz[x] += sz[y]; if(sz[y] &gt; sz[son[x]]) son[x] = y; }}void dfs2(int x, int top) { tp[x] = top; dfn[x] = ++idx; ptn[dfn[x]] = x; if(son[x]) dfs2(son[x], top); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x] || y == son[x]) continue; dfs2(y, y); }}inline int lca(int x, int y) { while(tp[x] != tp[y]) { if(d[tp[x]] &gt; d[tp[y]]) swap(x, y); y = fa[tp[y]]; } return d[x] &lt; d[y] ? x : y;}int main() { n = read(); for(register int i = 1; i &lt;= n; i++) w[i] = read(); for(register int i = 1; i &lt; n; i++) add(read(), read()); dfs1(1); dfs2(1, 1); a[w[1]] = 1; for(register int i = 2; i &lt;= n; i++) { delta[w[i - 1]]++; delta[w[i]]++; delta[fa[lca(w[i - 1], w[i])]] -= 2; a[lca(w[i - 1], w[i])]--; } for(register int i = n; i &gt;= 1; i--) a[ptn[i]] += delta[ptn[i]], delta[fa[ptn[i]]] += delta[ptn[i]]; for(register int i = 1; i &lt;= n; i++) write(a[i] - 1); return 0;}","link":"/2019/07/18/Luogu-P3258-JLOI2014-松鼠的新家-解题报告/"},{"title":"Luogu P3396 哈希冲突 解题报告","text":"根号分治入门题 题目链接P3396 哈希冲突 题意简述给你一个序列，每次查询模p意义下某数总和，或者更改某一个数。 解题思想先考虑暴力怎么打，显然有两种操作：一是先$O(n ^ 2)$预处理出模$i$意义下余数为$j$的答案，然后可以做到$O(1)$查询，$O(n)$修改。 二是对于每一次询问，暴力$O(n)$统计，修改是$O(1)$的。 两种做法的总复杂度都是$O(n ^ 2)$的，且第一种做法空间也会炸。 观察到两种做法查询修改互补，我们可以考虑结合一下：对于模数较小的情况，我们可以预处理出来，这样空间不会炸，修改范围也会变小。 对于模数较大的情况，我们暴力统计，这样结果不会过多，查询不会炸。 这个较大较小的界，我们可以定为$O(\\sqrt n)$，所以总复杂度为$O(n\\sqrt n)$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 150010;const int SIZE = 400;int n, m;int a[N];int f[SIZE][SIZE];int main() { n = read(), m = read(); int size = sqrt(n); for(register int i = 1; i &lt;= n; i++) { a[i] = read(); for(register int j = 1; j &lt;= size; j++) { f[j][i % j] += a[i]; } } while(m--) { char s[3]; scanf(\"%s\", s); int x = read(), y = read(); if(s[0] == 'A') { if(x &lt;= size) write(f[x][y]); else { int ans = 0; for(register int i = y; i &lt;= n; i += x) { ans += a[i]; } write(ans); } } else { for(register int i = 1; i &lt;= size; i++) { f[i][x % i] += y - a[x]; } a[x] = y; } } return 0;}","link":"/2019/08/26/Luogu-P3396-哈希冲突-解题报告/"},{"title":"Luogu P3623 [APIO2008]免费道路 解题报告","text":"生成树太蔡了来练一练。 题目链接P3623 [APIO2008]免费道路 题意简述给你一张图，边权为$0$或$1$，求权值为$k$的生成树。 解题思想我们先把边权为0的边优先加入生成树，然后可以得到一些边权为1的必须加入生成树的边，对它们打上标记。 然后再把边权为1的边优先加入生成树，并且要优先加入有标记的边，然后当边权为1的边加到$k$条时就跳到边权为0的边加完剩下的生成树就行了。 判定无解需要考虑生成树权值是否为k和是否构成生成树。 注意题目中读入的0和1是反的… 要求输出的0和1也是反的… 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;using std::sort;const int N = 2e4 + 5;const int M = 1e5 + 6;int n, m, k, cnt;int fa[N];int find(int x) {return fa[x] == x ? x : fa[x] = find(fa[x]);}struct edge { int x, y, z, mark;} e[M];inline bool cmp1(edge a, edge b) { return a.z &lt; b.z;}inline bool cmp2(edge a, edge b) { if(a.z == b.z) return a.mark &gt; b.mark; return a.z &gt; b.z;}int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for(register int i = 1; i &lt;= m; i++) { int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); e[i] = edge{x, y, 1 - z}; } for(register int i = 1; i &lt;= n; i++) fa[i] = i; sort(e + 1, e + m + 1, cmp1); for(register int i = 1; i &lt;= m; i++) { int x = e[i].x, y = e[i].y; if(find(x) == find(y)) continue; fa[find(x)] = find(y), cnt++; if(e[i].z) e[i].mark = 1; if(cnt == n - 1) break; } cnt = 0; sort(e + 1, e + m + 1, cmp2); for(register int i = 1; i &lt;= n; i++) fa[i] = i; for(register int i = 1; i &lt;= m; i++) { if(e[i].mark) {fa[find(e[i].x)] = find(e[i].y); cnt++, k--; continue;} if(find(e[i].x) == find(e[i].y)) continue; fa[find(e[i].x)] = find(e[i].y); cnt++; e[i].mark = 1; if(e[i].z) k--; if(!k) for(; e[i].z; i++); if(cnt == n - 1) break; } if(k) return puts(\"no solution\"), 0; for(register int i = 1; i &lt;= m; i++) { if(e[i].mark) k++; } if(k &lt; n - 1) return puts(\"no solution\"), 0; for(register int i = 1; i &lt;= m; i++) { if(e[i].mark) printf(\"%d %d %d\\n\", e[i].x, e[i].y, 1 - e[i].z); } return 0;}","link":"/2019/08/03/Luogu-P3623-APIO2008-免费道路-解题报告/"},{"title":"2019寒假成都摸鱼记","text":"前言还没放寒假的时候就知道要出去了，而且不用考生物，也是比较期待吧，于是肆意颓whk。这篇游记是Day7晚上在火车上写的，大多数印象比较清晰，知识点忘完了。 游记较长，大家可以跳着看。 Day -inf突然听说寒假要出去玩，还不用考生物，感觉很爽，也开始期待这场旅行（颓文化课）了。 Day -1上午考完英语后，就往校门口跑。没到门口就看到我爹了，但没看到潘老师。打电话才知道去考场找我们去了，假，连我在桌子上留的纸条都没看见。总归是到校门口了，就往火车站走。在赶时间的情况下，还在火车站对面的铁酒吃了一顿不错的午餐，心真是大。不过也没有很赶啦，着急地去了候车室后发现还早，就玩起了手机。候车的时候吃逼乎的安利下了这个神奇的计算器：Kalkyl（真叫这个，不是乱码） 居然可以画图像！虽然我严重怀疑这个${f(x)=x^x}$的图像画的有问题. 玩了会觉得没啥意思，然后就上车了。 在车上写了贪心的学习报告。本来准备写完后写线性DP的，但是鉴于贪心写了1000+（我太懒了），就没写了，开始颓CSGO。 打了一下午死斗，全是机器人一点都不好玩。手机也没有信号，又回忆起在重庆旅游时手机有信号没电的痛了…… 补了《Unnatural》的第一话，太好看了wocccccccccc！！可为什么硕鼠不能下载收费视频啊QAQ。 也没有全程颓啦，玩累了后把洛谷blog上的文章搬到了hexo上，顺便修改了一下补以前的锅。 关于《巴黎圣母院》，我忘了。 晚上没睡好QAQ，对面的小孩是真的吵。就晕晕地睡了大概四个小时。 这无所事事的一天就过去了。 Day 0早上6:00到站，第一感觉就是，火车站怎么跟襄阳站一样破，才知道这是老城区。（去的照片搞丢了，这是回来的时候照的） 出站后，找了好久才看到龟缩在角落的KFC，吃的也不算是丰盛。 实在是太困了…于是去了锦里的Starbucks，太早了人家都还没营业，好心的店主先把我们放进去了www。 待到了大概9:30的样子，回酒店了。感觉从酒店去锦里的时间比从锦里去酒店的时间要长的多。在酒店大堂看到了关老师(没上一节课的班主任)。 领了听课证、课表和笔记本后，就去吃午饭了。没吃火锅.难受.jpg。下午也没干啥，在酒店打了一下午LOL。 然后Day 0就结束了，依然无所事事。 Day 1起的早，在食堂吃了早饭后，得知教室居然在食堂里面？？？不过还不错啦。 最开始是hcy老师讲搜索，DFS我就没会过，讲了个框架，剩下大部分是讲例题。八皇后到是会，但八数码是啥啊……讲八数码，hcy就开始讲Hash，说到Hash，我就想到一个月前在机房用STL_SetA掉的字符串哈希，但是八数码好像并不能用Set做……一整节课，基本上强制在线。 搜索终于讲完了，接着讲的是贪心，这个我会。 国王游戏终于可以自己推了，高精依然不会（想）写。 贪心大概就是做题讲题做题讲题，知识性的东西并不多。 再然后就是分治与二分（没讲三分QAQ）。 思想还是清楚了，毕竟学过。然而在做题的时候发现自己打的好像是个假的二分板子： 12345while(l+1&lt;r){ int mid=(l+r)&gt;&gt;1; if(ans&gt;=mid)mid=l; else mid=r;} 然后自己的DEBUG套路好像也行不通了（增减”=“号与+1或-1）。 于是老老实实地就题论题打板子。 至于快速幂，讲的板子好像和我打的又不太一样还好我那个也能用。 晚上把部分题写了写，剩下了一些（懒得）难以实现的。 回到酒店后颓了几集《Unnatural》。 Day 1就结束了。 Day 2没吃早饭（真的吃不下） 早上去了没来什么人？？？（果然都吃早饭去了） 一整天都在讲数据结构。 二叉堆？_priority_queue_就好了！ 二叉搜索树？_set_就好了！ 改革春风吹满地，_STL_真争气。 然后就讲起了并查集。 板子还是比较熟的，不过老师没讲按秩合并，只讲了路径压缩。 这是按秩合并的板子: 12345678int fa[maxn],size[maxn];void init(int n){for(register int i=1;i&lt;=n;i++){fa[i]=i;size[i]=1;}}int find(int x){return fa[x]==x?x:find(fa[x]);}void merge(int x,int y){ int xx=find(x),yy=find(y); if(size[xx]&gt;size[yy])swap(xx,yy); fa[xx]=yy;size[yy]+=size[xx];} 讲起了线段树： 我果然还是不会有灵魂（Lazy Tag ）的线段树QAQ。懂是懂了，但是怎么实现啊 在luogu找了题解学习，大概明白怎么实现了。 讲完lazy tag，又讲了一大堆玄学？ 那一刻，仿佛所有题都能套线段树A掉。线段树太棒了 树状数组离线了……学不来晚上写了一写题目，很多堆部分的练习以前都写过。 期望的RMQ和LCA都没有讲。 Day 2结束了。 Day 3考试日。 上午在讲数论，并没有慌得一批。 gcd有一个更加简短的实现了： 1int gcd(int a,int b){return b?gcd(b,a%b):a;} lcm相对简单: 1int lcm(int a,int b){return a*b/gcd(a,b);} 关于扩展欧几里得，以前打乘法逆元的板子时了解过，一直不会推，现在也会了。这里只给出代码： 123456789int exgcd(int a,int b,int &amp;x,int &amp;y){ if(!b){ x=1;y=0; return a; } int g=exgcd(b,a%b,y,x); y-=a/b*x; return g;} 然后是筛法的预备知识：质数判定： 只需要枚举到${\\sqrt n}$就行了,但需要注意从2枚举。 1234567bool check(int n){ if(n==1||n==0) return 0; for(register int i=2;i&lt;=sqrt(n);i++){ if(!(n%i)) return 0;//一定要注意位运算符优先于算数运算符 } return 1;} 然后是埃氏筛（好久没打写挂了好几次）： 12345678for(register int i=1;i&lt;=maxn;i++){ if(check(i)&amp;&amp;!vis[i]){ is[i]=1; for(register int j=i;j&lt;=maxn;j+=i){ vis[i]=1; } } } 质因数分解：不放在这了。 最后就是逆元了： 可以运用费马小定理： ${a^{p-1}}$ ≡ 1 (mod p),p为质数,a与p互质 （注意p为质数，不过noip如果要求逆元，p肯定是质数） 由此可得： a*${a^{p-2}}$ ≡ 1 (mod p)所以，当模数为质数p时，a的逆元等于${a^{p-2}}$‘ 当然也可以运用扩展欧几里得，这里不再赘述。 知识点就这些，也没写到什么题。下午就开始考试了。 这是题目： T1随便写（虽然考场上没写优化挂了60分） T2在考场上想了一个用set维护的骚操作，复杂度带log，应该能过，可惜最大值维护错了。 这是改后的代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;set&gt;#define max(a,b) a&gt;b?a:b#define maxn 100010using namespace std;set&lt;int&gt;a;set&lt;int&gt;::iterator it;int main(){ freopen(\"guinness.in\",\"r\",stdin); freopen(\"guinness.out\",\"w\",stdout); int m,x,n,t,cnt=1,ans,maxx=0; scanf(\"%d\",&amp;m); for(register int i=1;i&lt;=m;i++){ scanf(\"%d\",&amp;x); a.insert(x); } scanf(\"%d\",&amp;t); for(register int i=1;i&lt;=t;i++){ it=a.begin();ans=1; scanf(\"%d\",&amp;n);cnt=0;int tmp[n+1]; for(register int j=1;j&lt;=n;j++){ scanf(\"%d\",&amp;x); tmp[++cnt]=x; bool getans = 0; for(it,ans;it!=a.end();it++,ans++){ if(x&lt;*it){ printf(\"%d \",ans); getans=1; break; } } if (!getans) printf(\"%d \",a.size()+1); } printf(\"\\n\"); while(cnt) a.insert(tmp[cnt]),cnt--; } fclose(stdin);fclose(stdout); return 0;} T3可以爆搜，但是没时间（懒得写）了，就没写，直接交上去了。 所以成绩并不是很好。 Expected:140 Score:40 Day 4换老师了。 今天讲的是图论。 先讲了一大堆图的概念，学过了，所以在下面复习Dijkstra+Heap 然后开始讲图的存储方式，前向星听了一下，剩下的学过，继续颓Dijkstra+Heap 终于开始讲最短路了：果然开始就讲Dijkstra…没有堆优化太咸了!!! 于是继续颓Dijkstra+Heap… 讲完后开始讲可爱的SPFA了，标准版的最短路果然还是构造数据卡了SPFA。 挂个SPFA的工作图: 关于Bellman Ford，只是提了一下和SPFA很像，丢了一个blog链接，并没有细讲。 讲完单源，自然开始讲多源 多源自然讲了可爱的$O(n^3)$的Floyd 五行代码真是太好了： 12345for(register int k=1;k&lt;=n;k++) for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=n;j++) if(map[i][k]+map[k][j]&lt;map[i][j]) map[i][j]=map[i][k]+map[k][j]; 在做题的过程中学了一些奇巧淫技： 比如： 多源一汇最短路径？存个反图跑SPFA: 死掉的SPFA也可以判负环：（代码摘自这里） 12345678910111213141516171819202122232425262728bool spfa(int n) { int u, v; while (!q.empty()) q.pop(); memset(vis, false, sizeof(vis)); memset(in, 0, sizeof(in)); fill(d, d + n, oo); d[0] = 0; vis[0] = true; q.push(0); while (!q.empty()) { u = q.front(); vis[u] = false; for (int i = prev[u]; i != -1; i = edge[i].next) { v = edge[i].v; if (d[u] + edge[i].t &lt; d[v]) { d[v] = d[u] + edge[i].t; if (!vis[v]) { in[v] ++; if (in[v] &gt; n) return true; vis[v] = true; q.push(v); } } } vis[u] = false; q.pop(); } return false;} 最短路讲完后是最小生成树，一样只是提了一下Prim，重点是Kruskal：使用了并查集，也非常好理解：直接给出代码实现： 123456789101112131415int find(int x){return fa[x]==x?x:find(fa[x]);}bool merge(int x,int y){ int xx=find(x);int yy=find(y); if(xx!=yy){ fa[xx]=yy; return 1; } return 0;}for(register int i=1;i&lt;=m;i++){ if(merge(s[i].x,s[i].y)){ sum+=s[i].w;cnt++; if(cnt==n-1) break; }} 非常好理解，于是讲的很快。 然后是TopSort（拓扑排序）：相当于是寻找InDegree=0的点，push，然后删除。 也很好理解。代码实现：(行吧这是课件上的代码我没看懂) 123456789101112131415161718192021bool TopologicalSort(DirectGraph &amp;g,vector&lt;int&gt;&amp;in_degree){ queue&lt;int&gt;qu; int cnt=0; for(auto ite=in_degree.begin();ite !=in_degree.end();++ite){ if(*ite==0){ qu.push(*ite); } } while(!qu.empty()){ int v=qu.front(); qu.pop(); printf(\"%d \",v); cnt++; for(const int &amp;i:g.adj.at(v)){ if(0==--in_degree[i]){ qu.push(i); } } } return cnt&gt;=v;} 最后讲了树上倍增求LCA（该来的总是会来） 知识听懂了，但是实现过程看的稀里糊涂的，几乎强制在线 就像中国RMB一样，每次都尝试最大的${2^i \\leq n}$，总能凑出LCA位置，毕竟${2^0 =1}$嘛。 晚上写了个Dijkstra+Heap的A+B Problem（我太咸了） 回酒店依然补剧… Day 5讲DP，本来满怀期待的，后来发现好多题以前都写过… 唯一值得一提的是01背包的原理又理解了一遍，比以前掌握的好多了。 Day 5没啥好写的。 Day 6又是考试日。也换老师了。 上午讲的STL，也没啥好写的，会的以前都会，不会的比如全排列，无非感叹很有用，然后会用了，也没什么好说，（所以这玩意真方便）。 下午的考试： 解压后看T1，看了看数据范围，觉得60pts打表能出，很稳，就开了Excel，写T1 Expected 60 5分钟写了暴力挂在那打表，开始看T2。 T2感觉没啥思路，打暴力的时候把dfs忘了（果然我还是不会dfs）写了${O(n^3)}$的存图，然后T1还没跑完，很慌，关了exe，把源程序的20改成了10打表，打开一看： …… 直接撸快速幂，100到手。 表变成了这个 那个tip还是我手画了一棵树后验证的 实在想不出来，一脑抽，就把T1交了…… 然后看到群里的： 然后…. …… 不得不滚回去打T2了。 暴力写挂了…… T3依然不知道在讲什么。 所以考试算是半凉凉吧…… Expected 160 Score=100 莫名rk3。 Day 7上午讲了历年的一些题。 听懂了xkdyh的玄学解法，也会了货币系统老凯的疑惑 心心念念的天天爱跑步没讲 直到Day 7我才知道原来课表里面没有KMP 然后就结束了。 突然想到要滚回去上whk了，对这个地方还是有点不舍。 挂几张照片吧。 Day inf卧在学校里，终于补了这篇游记的锅，虽然干货不多，但是知识点会慢慢写总结。 做该做的，才对的起自己。","link":"/2019/02/01/2019寒假成都摸鱼记/"},{"title":"Luogu P3244 [HNOI2015]落忆枫音 解题报告","text":"题目链接P3244 [HNOI2015]落忆枫音 题目背景这个题目背景我一定要放上来（ 「恒逸，你相信灵魂的存在吗？」 郭恒逸和姚枫茜漫步在枫音乡的街道上。望着漫天飞舞的红枫，枫茜突然问出这样一个问题。 「相信吧。不然我们是什么，一团肉吗？要不是有灵魂……我们也不可能再见到你姐姐吧。」 恒逸给出了一个略微无厘头的回答。枫茜听后笑了笑。 「那你仔细观察过枫叶吗？」 说罢，枫茜伸手，接住了一片飘落的枫叶。 「其实每一片枫叶都是有灵魂的。你看，枫叶上不是有这么多脉络吗？我听说，枫叶上有一些特殊的位置，就和人的穴位一样。脉络都是连接在这些穴位之间的。枫树的灵魂流过每片枫叶的根部，沿着这些脉络，慢慢漫进穴位，沁入整片枫叶。也是因为这个原因，脉络才都是单向的，灵魂可不能倒着溜回来呢。」 恒逸似懂非懂地点了点头。枫茜接着说了下去。 「正是因为有了灵魂，每片枫叶才会与众不同。也正是因为有了灵魂，每片枫叶也都神似其源本的枫树，就连脉络也形成了一棵树的样子。但如果仔细看的话，会发现，在脉络树之外，还存在其它的非常细的脉络。虽然这些脉络并不在树上，但他们的方向也同样顺着灵魂流淌的方向，绝不会出现可能使灵魂倒流的回路。」 恒逸好像突然想到了什么。 「那这些脉络岂不是可以取代已有的脉络，出现在脉络树上？」 枫茜闭上了眼睛。 「是啊，就是这样。脉络树并不是唯一的。只要有一些微小的偏差，脉络树就可能差之万里，哪怕是在这同一片枫叶上。就像我们的故事，结局也不是唯一的。只要改变一个小小的选项，故事流程可能就会被彻底扭转。」 「真是深奥啊……」 恒逸盯着这片红枫，若有所思地说。枫茜继续说道。 「还不止如此呢。所有的脉络都不会永恒存在，也不会永恒消失。不管是脉络树上的脉络，还是之外的细小脉络，都是如此。存在的脉络可能断开消失，消失的脉络也可能再次连接。万物皆处在永恒的变化之中，人与人之间的羁绊也是。或许有一天，我们与大家的羁绊也会如同脉络一样，被无情地斩断。或许我们也终将成为”枫音乡的过客“。或许这一切都会是必然，是枫树的灵魂所决定的……」 枫茜的眼角泛起了几滴晶莹剔透的泪珠。恒逸看着这样的枫茜，将她抱入怀中。 「别这样想，枫茜。就算脉络断开，也有可能还会有新的脉络树，也还会与枫树的根相连。这样的话，我们的羁绊仍然存在，只是稍微绕了一些远路而已。无论如何，我都不会离开你的。因为你是我穷尽一生所寻找的，我的真恋啊！」 两人的目光对上了。枫茜幸福地笑了，把头埋进了恒逸的怀抱。从远方山上的枫林中，传来了枫的声音。 题意描述不妨假设枫叶上有 n个穴位，穴位的编号为 1 ~ n。有若干条有向的脉络连接着这些穴位。穴位和脉络组成一个有向无环图——称之为脉络图（例如图 1），穴位的编号使得穴位 1 没有从其他穴位连向它的脉络，即穴位 1 只有连出去的脉络；由上面的故事可知，这个有向无环图存在一个树形子图，它是以穴位 1为根的包含全部n个穴位的一棵树——称之为脉络树（例如图 2和图 3给出的树都是图1给出的脉络图的子图）；值得注意的是，脉络图中的脉络树方案可能有多种可能性，例如图2和图 3就是图 1给出的脉络图的两个脉络树方案。 脉络树的形式化定义为：以穴位 r 为根的脉络树由枫叶上全部 n个穴位以及 n- 1 条脉络组成，脉络树里没有环，亦不存在从一个穴位连向自身的脉络，且对于枫叶上的每个穴位 s，都存在一条唯一的包含于脉络树内的脉络路径，使得从穴位r 出发沿着这条路径可以到达穴位 s。 现在向脉络图添加一条与已有脉络不同的脉络（注意：连接 2个穴位但方向不同的脉络是不同的脉络，例如从穴位3到4的脉络与从4到3的脉络是不同的脉络，因此，图 1 中不能添加从 3 到 4 的脉络，但可添加从 4 到 3 的脉络），这条新脉络可以是从一个穴位连向自身的（例如，图 1 中可添加从 4 到 4 的脉络）。原脉络图添加这条新脉络后得到的新脉络图可能会出现脉络构成的环。 请你求出添加了这一条脉络之后的新脉络图的以穴位 1 为根的脉络树方案数。 由于方案可能有太多太多，请输出方案数对 1,000,000,007 取模得到的结果。 解题思想考虑未加边的情况，此时图是一个DAG，记为$G=(V, E)$，我们需要统计它的树形子图。 考虑树的特性，每个节点有且仅有唯一一个父节点，那么我们可以根据乘法原理，将每个非根节点的入度累乘，即可得到答案为：$$\\prod\\limits_{i = 2}^{n} \\deg i$$ 考虑加边，依然按照上面的方式统计，这样会统计到不合法答案。 我们考虑统计不合法答案，然后用原答案减去它。 可以发现，在原图的DAG上加一条边，若答案不合法，则这个加边后的图一定含有环。又因为原图是一个DAG，所以这个环一定含有加上的边。 于是可以枚举环上的点集$S$，为其钦定父节点，然后将非环上节点照旧统计，可以得到所有不合法答案，即为：$$\\sum\\limits_{S}\\prod\\limits_{i\\notin S} \\deg i$$ 这个答案可以DP出来。 设dp[i]表示路径$i\\rightarrow x$上节点成环的情况数，那么有初始值：$$dp[x] = \\prod\\limits_{y : y \\in V 且 y \\neq x}\\deg y$$ 由于我们为每个环上的节点钦定了父节点，所以对于一个点$x$，我们将其统计入环时，它对不合法情况的贡献会由$\\deg x$变为$1$，所以转移时需要除去它的入度。 那么状态转移方程为： $$dp[x] = \\frac {\\sum\\limits_{y : (x, y)\\in E}dp[y]} {\\deg x}$$ 整个DP是$O(n)$的，如果在线求逆就是$O(n \\log n)$的。 最后的答案就是总方案减去不合法数，注意DP完成后节点$x$的父节点未考虑减少的贡献，所以需要除以$\\deg x$，即：$$ans = \\prod\\limits_{i = 2}^{n}\\deg i - \\frac {dp[x]} {\\deg x}$$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MOD = 1e9 + 7;const int N = 2e5 + 6;const int M = N &lt;&lt; 1;inline int mul(int a, int b) {return 1ll * a * b % MOD;}inline int add(int a, int b) {return a + b &gt; MOD ? a + b - MOD : a + b;}inline int power(int a, int b) {int res = 1; for(; b; b &gt;&gt;= 1, a = mul(a, a)) if(b &amp; 1) res = mul(res, a); return res;}int n, m, y, x, ans = 1;int dp[N], in[N];int head[N], nxt[M], ver[M], cnt;inline void adde(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt, in[y]++;}int dfs(int x) { if(~dp[x]) return dp[x]; dp[x] = 0; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; dfs(y); dp[x] = add(dp[x], dp[y]); } dp[x] = mul(dp[x], power(in[x], MOD - 2)); return dp[x];}int main() { scanf(\"%d%d%d%d\", &amp;n, &amp;m, &amp;y, &amp;x); memset(dp, -1, sizeof(dp)); dp[y] = 1; for(register int i = 1; i &lt;= m; i++) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); adde(u, v); } for(register int i = 2; i &lt;= n; i++) { if(i == x) ans = mul(ans, in[i] + 1); else ans = mul(ans, in[i]); dp[y] = mul(dp[y], in[i]); } if(x == 1) return printf(\"%d\\n\", ans), 0; dp[y] = mul(dp[y], power(in[y], MOD - 2)); ans = add(ans, MOD - dfs(x)); printf(\"%d\\n\", ans); return 0;}","link":"/2019/08/03/Luogu-P3244-HNOI2015-落忆枫音-解题报告/"},{"title":"Luogu P3629 [APIO2010]巡逻 解题报告","text":"题目链接P3629 [APIO2010]巡逻 题意简述给你一张无向图，有$n$个点和$n - 1$条边，无重边和自环，边长都为$1$，给定源点$1$，新建$k$条道路，要求从源点出发，每条道路必须经过至少一次，且新建的道路必须仅经过一次，求可能的新建道路的方案，使遍历路径最短。 解题思想暴力就不讲了，应该都能想到。 我们直接考虑$100%$的数据。 注意原题中的$1\\le k \\le 2$，我们考虑分类讨论。 先来考虑$k == 1$的情况。在k == 1时，这道题和草鉴定有点像，但是读完题目后我们会发现，两道题的方向是相反的，要求也不同。 那要怎么做呢？ 先来看题目： 有$n$个点和$n - 1$条边，无重边和自环 这句话告诉我们，题中的图实质上是一颗无根树。 看到题目中描述的新道路甚至可以是自环（题意简述中没写），我们先来考虑这种情况： 当新道路是一个自环时，我们不能通过它来从一个点到另一个点。而又因题目要求，新道路必须经过一次，那么我们只会在新道路上浪费$1$巡逻距离，如图：（这是样例1） 根据DFS的思想，我们要想遍历途中的每一个节点，需要访问每一条边两次（访问一次，回溯一次）。可以得到巡逻距离为$2 \\times (8 - 1) = 14$。 如果我们添加的新道路为节点$2$的自环，我们就会在访问节点$2$时被强制经过新道路一次，但是自环访问完后，依然要从$2$回溯至$3$，因此添加任意的自环都仅会使最小访问距离变大，舍弃。 那么我们考虑在两个不同的节点之间连边。 在一棵树上连一条边的话，原树就会变成一颗基环树。 如图：连接了$7,2$两点。 那么如果必须经过新建道路，我们就必须经过基环树的环，这样，环上的道路都只需要遍历一次（因为我们可以通过环来回到某一个点，这样就可以遍历完环后直接回溯，而环上的边就不需要再增加回溯时的费用）。于是考虑让这个环的长度最大，也就是说，让连边前的链最长，于是可以求出原树的直径L，然后将直径的两端连边，那么答案就是$2 * (n - 1) - L + 1$。 其中$2 * (n - 1)$为遍历原树的费用，L - 1为环的长度（不明白的动手在上面的图中数一数）。 30分到手了不做了 再来考虑$k == 2$的情况和$k == 1$时相似，自环依然是被舍弃的，这个自己理解。 我们的第一条边依然连在直径两端，接着考虑第二条边的位置：不难看出有如下两种可能： 环重叠 环不重叠 先来连接直径的两端，如图： 这时的点$1 - 2 - 6 - 5 - 3$构成了一个环。我们考虑让环不重叠，连接点$7,8$，如图： 这时，新的环上的边也仅需经过一次，看上去非常的实惠。 别急，我们再来考虑一下重叠的情况，如图： 这次连接了$4,7$两个点。看上去形成了一个更大的环，节省了中间重叠部分的费用，但是是这样嘛？ 再次回去看一遍题目，发现了一个要求： 每条道路必须经过至少一次 这样，中间的道路就不能不走，如果走的话，不仅没有节省费用，相反会因为两个环都要经过而增加了重叠长度的费用。 结果就很显然了，需要连接两个不会导致重环的点。 那么要连接哪两个？怎么样才会导致不重环？ 考虑$k == 1$时的做法，我们尝试找一条次长链，而且不与原链重复。有了第二个要求，我们反而会比较好做： 只需要将原直径上的边毁掉，然后建立一颗新的树，再在这棵树上求出直径就好了。 但是可能会出现某些dl数据，让连边后不得不重环，其实计算后我们就会发现，不论是否重环，都需要用原图长度减去两个环的大小，而重叠的部分被减了两次（不需要容斥的），这点我们通过求出直径后把直径上的边权值取反就能达到。 取反的实现类似于EK算法的upd()操作，需要在第一遍bfs()求直径时维护一个pre[]数组。 第二条直径可以树上dp来求。 参考代码 恰当的函数使用可以极大减少码量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//Author: zgjjj#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 100010;const int M = N &lt;&lt; 2;template &lt;typename T&gt; inline T max(T a, T b) {return a &gt; b ? a : b;}template &lt;typename T&gt;class queue { private: int head, tail; T q[N &lt;&lt; 1]; public: queue() {head = tail = 0;} inline bool empty() {return head &gt;= tail;} inline void push(T x) {q[++tail] = x;} inline void pop() {if(!empty()) head++;} inline T front() {return q[head + 1];}};int head[N], nxt[M], edge[M], ver[M], d[N], pre[N];int cnt = 1, n, k, l, r, l1, l2;bool v[N];inline void add(int x, int y, int z) { ver[++cnt] = y, edge[cnt] = z, nxt[cnt] = head[x], head[x] = cnt;}inline int bfs(int s) { for(register int i = 1; i &lt;= n; i++) d[i] = 0xcfcfcfcf, pre[i] = v[i] = 0; int ans = 0; d[s] = 0; queue &lt;int&gt; q; q.push(s); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; d[y] = d[x] + z; pre[y] = i; q.push(y); } } for(register int i = 1; i &lt;= n; i++) if(d[ans] &lt; d[i]) ans = i; return ans;}void dp(int x) { v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; dp(y); l2 = max(l2, d[y] + d[x] + z); d[x] = max(d[x], d[y] + z); }}int main() { n = read(), k = read(); for(register int i = 1; i &lt; n; i++) { int x = read(), y = read(); add(x, y, 1); add(y, x, 1); } l = bfs(1); r = bfs(l); l1 = d[r]; if(k == 1) return write(2 * (n - 1) - l1 + 1), 0; int x = r; while(x != l) { int i = pre[x]; edge[i] = edge[i ^ 1] = -1; x = ver[i ^ 1]; } for(register int i = 1; i &lt;= n; i++) d[i] = v[i] = 0; dp(1); return write(2 * n - l1 -l2), 0;}","link":"/2019/06/06/Luogu-P3629-APIO2010-巡逻-解题报告/"},{"title":"Luogu P4306 [JSOI2010]连通数 解题报告","text":"高级暴力 翻了一下题解好像没人解法跟我一样 题目链接P4306 [JSOI2010]连通数 题意简述给你一张图，求它的连通数。 连通数：指图中可达顶点对个的个数。 解题思想如果$n$不大的话，我们可以跑传递闭包，然后统计答案，这个比较暴力，是$O(n^3)$的，显然过不了2000但是数据水好像能过 我们考虑将范围缩小：不妨对原图缩点，这样的话$n$的范围期望大大减小。（可能被卡） 然后在缩点后的图上传递闭包，就不会超时了。 但是答案统计的方法和以前要有所区别：如果直接对原图传递闭包，我们仅需$O(n^2)$遍历一遍然后ans++就行了。 对于这个缩完的DAG，我们考虑每两个连通块联通对答案的贡献：根据乘法原理，两个连通块贡献的连通数与块大小有关，假定两个连通块分别为$A,B$，那么这个贡献就是$size_A\\times size_B$，其中$size_i$表示连通块$i$包含的节点个数。 那么，推广到所有连通块上，总连通数即为：$$\\sum \\limits_{i, j\\in DAG} size_i \\times size_j$$ 需要注意的是，当原图每个点各为一个强连通分量时，该算法会上界会跑满。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 2010;const int M = N * N;inline int min(int a, int b) {return a &lt; b ? a : b;}inline int max(int a, int b) {return a &gt; b ? a : b;}int n, m, ans;int head[N], nxt[M], ver[M], cnt;int scc[N], num[N], dfn[N], low[N], idx, tot;bool v[N];int sta[N], stop;bool f[N][N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}void tarjan(int x) { dfn[x] = low[x] = ++idx; sta[++stop] = x; v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); } else if(v[y]) { low[x] = min(low[x], dfn[y]); } } if(dfn[x] == low[x]) { tot++; while(stop) { int y = sta[stop--]; scc[y] = tot; v[y] = 0; num[tot]++; if(x == y) break; } }}void rebuild() { for(register int x = 1; x &lt;= n; x++) { for(register int i = head[x]; i; i = nxt[i]) { if(scc[x] != scc[ver[i]]) f[scc[x]][scc[ver[i]]] = 1; } }}char s[N][N];int main() { n = read(); for(register int i = 1; i &lt;= n; i++) scanf(\"%s\", s[i] + 1); for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= n; j++) { if(s[i][j] == '1') add(i, j); } } for(register int i = 1; i &lt;= n; i++) if(!dfn[i]) tarjan(i); rebuild(); for(register int i = 1; i &lt;= tot; i++) { f[i][i] = 1; for(register int j = 1; j &lt;= tot; j++) { for(register int k = 1; k &lt;= tot; k++) { f[i][j] |= f[i][k] &amp; f[k][j]; } } } for(register int i = 1; i &lt;= tot; i++) { for(register int j = 1; j &lt;= tot; j++) { if(f[i][j]) ans += num[i] * num[j]; } } if(tot == 1) ans = num[1] * num[1]; write(ans); return 0;}","link":"/2019/08/01/Luogu-P4306-JSOI2010-连通数-解题报告/"},{"title":"Luogu P4408 [NOI2003]逃学的小孩 解题报告","text":"题目链接P4408/NOI2003 逃学的小孩 题意简述给你一棵树，求树上的三个点$A,B,C$，满足$AB + BC$最长，且$BC&lt;AC$ 解题思想其实三个点位置的顺序不重要，我们可以两两交换得到一个固定的顺序，为了方便我就使用了$AB + BC$。 首先，图中两点之间有且仅有一条简单路径，说明这张图是一棵树。 要求三个点间的最大距离的话，我们不妨钦定有两个点间的路径长度为树的直径。可以通过微扰证明无法构造更优的方案。 对于剩下的点，我们在计算树的直径时顺便计算直径的顶点到树上每一个点的距离，然后枚举图中的每一个点，考虑这个点到直径两端的距离，用两者的较小值更新答案。 注意：要开long long 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;cctype&gt;#define int long longnamespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) {putchar('-'), x = -x;} if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 200020;const int M = N &lt;&lt; 2;template &lt;typename T&gt;class queue { private: int head, tail; T q[N &lt;&lt; 1]; public: queue() {head = tail = 0;} inline bool empty() {return head &gt;= tail;} inline void push(T x) {q[++tail] = x;} inline void pop() {if(!empty()) head++;} inline T front() {return q[head + 1];}};template &lt;typename T&gt; inline T max(T a, T b) {return a &gt; b ? a : b;}template &lt;typename T&gt; inline T min(T a, T b) {return a &lt; b ? a : b;}int head[N], nxt[M], ver[M], edge[M];int dl[N], dr[N];bool v[N];int n, m, cnt, l, r, ans;inline void add(int x, int y, int z) { ver[++cnt] = y, edge[cnt] = z, nxt[cnt] = head[x], head[x] = cnt;}signed main() { n = read(), m = read(); for(register int i = 1; i &lt;= m; i++) { int x = read(), y = read(), z = read(); add(x, y, z); add(y, x, z); } queue &lt;int&gt; q; q.push(1); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; dl[y] = dl[x] + z; q.push(y); } } for(register int i = 1; i &lt;= n; i++) if(dl[i] &gt; dl[l]) l = i; for(register int i = 1; i &lt;= n; i++) v[i] = 0; dl[l] = 0; q.push(l); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; dl[y] = dl[x] + z; q.push(y); } } for(register int i = 1; i &lt;= n; i++) if(dl[i] &gt; dl[r]) r = i; for(register int i = 1; i &lt;= n; i++) v[i] = 0; q.push(r); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; dr[y] = dr[x] + z; q.push(y); } } for(register int i = 1; i &lt;= n; i++) { ans = max(ans, min(dl[i], dr[i])); } ans += dl[r]; write(ans); return 0;}","link":"/2019/06/05/Luogu-P4408-NOI2003-逃学的小孩-解题报告/"},{"title":"Luogu P4742 [Wind Festival]Running In The Sky 解题报告","text":"屑题卡我两天，这可能是我写过的最长的蓝题了。 题目链接P4742 [Wind Festival]Running In The Sky 题意简述给你一张有向图，有点权，一个点的费用可被收取当仅当第一次经过该点，求出最长路和该路径上点权最大值。 解题思想缩点没什么好说的，但是在缩点时我们维护每个强连通分量的两个信息： 点权之和info[0][i] 点权最大值info[1][i] 缩完点后建立新图，就不用多说了。 然后在新图上拓扑排序的同时DP，维护到每个点的最长路，同时有依赖性地更新点权最大值。 这个有依赖性就是难点。 我们考虑独立DP极大值，可以很轻易地被Hack掉，考虑一条路径，上面有一个点权值极大，其余的点权值全为0，再构造另一条路径，每个点的权值仅比上条路径权值极大点小1，这样我们DP出的结果很明显不在最长路上。 那要怎么做呢？ 考虑仅在最长路径转移的时候转移极大值的状态，即单独考虑两条路长度相等的情况。 那么拓扑排序时就有两种情况： 一是最长路更新，这时需要更新最大点权，与新加入的点的权值进行对比。 二是发现等长路径，这是也需要更新最大点权，但是与新加入点的状态进行对比。 很好想通，发现等长路径时，我们需要将原状态与整条路径上的点权进行对比，这就是新加入点的状态了。 参考代码写的比较工程化，所以很长。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); putchar(' '); }}namespace Data { static const int N = 2e5 + 6; static const int M = 5e5 + 6; template &lt;typename T&gt; T max(T a, T b) {return a &gt; b ? a : b;} template &lt;typename T&gt; T min(T a, T b) {return a &lt; b ? a : b;} template &lt;typename T&gt; class queue { private: int head, tail; T q[N]; public: queue() {head = tail = 0;} inline bool empty() {return head &gt;= tail;} inline void push(T x) {q[++tail] = x;} inline void pop() {if(!empty()) head++;} inline T front() {return q[head + 1];} }; template &lt;typename T&gt; class stack { private: int stop; T s[N]; public: inline bool empty() {return stop == 0;} inline void push(T x) {s[++stop] = x;} inline void pop() {if(!empty()) stop--;} inline T top() {return s[stop];} }; int n, m; int head[N], nxt[M], ver[M], k[N], cnt; int scc[N], low[N], dfn[N], info[2][N], dp[2][N], idx, tot; bool v[N]; stack &lt;int&gt; s; int Head[N], Ver[M], Nxt[M], in[N], Cnt;}using namespace FastIO;using namespace Data;inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}void tarjan(int x) { dfn[x] = low[x] = ++idx; v[x] = 1; s.push(x); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); } else if(v[y]) { low[x] = min(low[x], dfn[y]); } } if(low[x] == dfn[x]) { tot++; while(s.top()) { int y = s.top(); s.pop(); v[y] = 0; scc[y] = tot; info[0][tot] += k[y]; info[1][tot] = max(info[1][tot], k[y]); if(x == y) break; } }}inline void Add(int x, int y) { Ver[++Cnt] = y, Nxt[Cnt] = Head[x], Head[x] = Cnt, in[y]++;}inline void rebuild() { for(register int x = 1; x &lt;= n; x++) { for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(scc[y] != scc[x]) Add(scc[x], scc[y]); } }}inline void TopSort() { queue &lt;int&gt; q; for(register int i = 1; i &lt;= n; i++) { dp[0][i] = info[0][i]; dp[1][i] = info[1][i]; if(in[i] == 0) q.push(i); } while(!q.empty()) { int x = q.front(); q.pop(); for(register int i = Head[x]; i; i = Nxt[i]) { int y = Ver[i]; if(dp[0][y] &lt; dp[0][x] + info[0][y]) { dp[0][y] = dp[0][x] + info[0][y]; dp[1][y] = max(dp[1][x], info[1][y]); } else if(dp[0][y] == dp[0][x] + info[0][y]) { dp[1][y] = max(dp[1][y], dp[1][x]); } in[y]--; if(in[y] == 0) q.push(y); } }}int main() { n = read(), m = read(); for(register int i = 1; i &lt;= n; i++) { k[i] = read(); } for(register int i = 1; i &lt;= m; i++) { int x = read(), y = read(); add(x, y); } for(register int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } rebuild(); TopSort(); int las = 1; for(register int i = 2; i &lt;= tot; i++) { if(dp[0][i] &gt; dp[0][las] || (dp[0][i] == dp[0][las] &amp;&amp; dp[1][i] &gt;= dp[1][las])) las = i; } write(dp[0][las]); write(dp[1][las]); return 0;}","link":"/2019/05/07/Luogu-P4742-Wind-Festival-Running-In-The-Sky 解题报告/"},{"title":"Nim博弈 学习报告","text":"Nim取石子游戏甲，乙两个人玩Nim取石子游戏。nim游戏的规则是这样的：地上有n堆石子（每堆石子数量小于10000），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。 结论Nim博弈先手必胜，当且仅当：$$XOR_{a_1}^{a_n}=0$$ 证明（此部分搬运 y2823774827y的题解，在此对原作者表示敬意） 用比较通俗的方式讲一下吧： 题目本意是给出n堆石子，轮流在其中一堆去任意个，谁不能去谁就输。 思路：证明所有石子异或和为0则先手必输 证明： 反正最终情况就是每堆都为0，先手必输，所以我们考虑怎么把情况转换到这里。 如果异或和的最高位为i，则有一堆石子第i为为1（不然怎么会有i位） 设A1就为那堆石子，其他堆石子异或和设为x，总异或和设为k，则 A1 xor x=k，把A1变成A1 xor k，那么后手面对的则是（A1 xor k）xor x=0， 举个例子:11001 xor 11100=101，则有（11001 xor 101）xor 11100=0 如果现在的异或和已经为0了（不为最终情况），那么怎么转换异或和都不能为0 好，我们根据3 4点得出：如果先手异或和不为0，可以一步让后手的情况为异或和为0；如果先手异或和为0，那么后手异或和就不为0 终于开始进行游戏了，如果现在先手面对的情况异或和不为0，则一直让后手异或和为0，最后面对最终情况，后手输，则先手赢；如果先手面对的情况异或和为0，后手则赢 SG函数与ICG游戏这里不讲理论了，论应用的话，我的SG函数多半是打表或者手玩出来的，真正使用所谓$\\mathbf {mex}$运算的很少。所以，不妨从实际问题出发，找出SG函数的规律，再对每个SG函数进行异或和。 先手必胜的条件为：$$\\oplus_{i = 1}^n\\mathbf{SG}(i) != 0$$ 例题 UVA1482 Playing With Stones这是一道典型的打表求SG规律的题。 题解在这：Click here","link":"/2019/03/05/Nim博弈-学习报告/"},{"title":"P5343 【XR-1】分块 解题报告","text":"太蠢了矩阵快速幂忘光了QAQ 题目链接P5343 【XR-1】分块 题意简述给你两个由长度构成的集合，求交集，再给你一个长度，求由交集中的长度划分的方法。（好像越讲越不清楚） 解题思想一次线性递推关系，可以用矩阵快速幂加速，这个大部分题解都讲了。 看到很多人都是排序+unique$O(n\\log n)$求的交集，这篇主要讲一讲一种$O(n)$求交集的方法。 由于矩阵乘法是$O(n^3)$的缘故，$x$的范围开的很小，不妨考虑桶排的思想，我们对序列$O(n)$扫两遍，筛出重复元素（可以通过与运算实现，也可以开两个数组），然后在扫一遍，将筛出的元素存起来，就能得到交集。 两个数组的方法实现如下： 12345678inline void get() { n = read(); num = read(); while(num--) t[read()] = 1; num = read(); while(num--) if(t[tmp = read()]) m[tmp] = 1; for(register int i = 1; i &lt;= 100; i++) if(m[i]) is[++tot] = i;} 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#define int long long//（逃const int MOD = 1e9 + 7;inline void Mul(int f[100], int a[100][100]) { int c[100]; memset(c, 0, sizeof(c)); for(register int j = 0; j &lt; 100; j++) { for(register int k = 0; k &lt; 100; k++) { c[j] = (c[j] + (long long) f[k] * a[k][j]) % MOD; } } memcpy(f, c, sizeof(c));}inline void Mulself(int a[100][100]) { int c[100][100]; memset(c, 0, sizeof(c)); for(register int i = 0; i &lt; 100; i++) { for(register int j = 0; j &lt; 100; j++) { for(register int k = 0; k &lt; 100; k++) { c[i][j] = (c[i][j] + (long long)a[i][k] * a[k][j]) % MOD; } } } memcpy(a, c, sizeof(c));}int n, num, tmp, is[101], tot;bool t[101], m[101];inline int read() { char ch = getchar(); int r = 0; while(!isdigit(ch)) ch = getchar(); while(isdigit(ch)) r = r * 10 + ch - '0', ch = getchar(); return r;}inline void get() { n = read(); num = read(); while(num--) t[read()] = 1; num = read(); while(num--) if(t[tmp = read()]) m[tmp] = 1; for(register int i = 1; i &lt;= 100; i++) if(m[i]) is[++tot] = i;}int ans[100], base[100][100];signed main() { get(); ans[99] = 1; for(register int i = 1; i &lt; 100; i++) base[i - 1][i] = 1; for(register int i = 1; i &lt;= tot; i++) base[99][100 - is[i]] = 1; while(n) { if(n &amp; 1) Mul(ans, base); Mulself(base); n &gt;&gt;= 1; } printf(\"%lld\", ans[99]); return 0;}","link":"/2019/05/05/P5343-【XR-1】分块-解题报告/"},{"title":"SDOI2009 SuperGCD解题报告(瞎搞)","text":"瞎搞的别康了。 题目简述高精求gcd 思想python不存在高精的 代码明明能更短 1print (__import__('fractions').gcd(int(input()),int(input()))) 人生苦短，我用python","link":"/2019/02/12/SuperGCD/"},{"title":"POJ 2631 Roads in the North 解题报告","text":"我没测，一次过了，有什么好说的。 题目链接POJ 2631 Roads in the North 题意简述给你一棵树，求距离最长的两个点。 解题思想首先要一眼看出题目中的图是一棵树。然后距离最长的两个点就是树的直径。 可以先任意节点为源bfs一次，求出到该点距离最长的一个点。再以它为源bfs一次，求出到该点距离最长的一个点。那么这两个点之间的距离就是这棵树的直径。 读入的时候需要记录一下最小点数和最大点数。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Junk POJ Doesn't Allow me to use &lt;bits/stdc++.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 10010;const int M = N &lt;&lt; 1;int head[N], nxt[M], edge[M], ver[M], cnt = 1;int n, m, s = N, t, l, r;int d[N], v[N];inline void add(int x, int y, int z) { ver[++cnt] = y, edge[cnt] = z, nxt[cnt] = head[x], head[x] = cnt;}int main() { int x, y, z; while(~scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;z)) { add(x, y, z); add(y, x, z); s = min(s, x); s = min(s, y); t = max(t, x); t = max(t, y); } queue &lt;int&gt; q; q.push(s); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; d[y] = d[x] + z; q.push(y); } } for(register int i = s; i &lt;= t; i++) { if(d[i] &gt; d[r]) r = i; } q.push(r); memset(v, 0, sizeof(v)); memset(d, 0, sizeof(d)); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; d[y] = d[x] + z; q.push(y); } } for(register int i = s; i &lt;= t; i++) { if(d[i] &gt; d[l]) l = i; } printf(\"%d\", d[l]); return 0;}","link":"/2019/06/04/POJ-2631-Roads-in-the-North-解题报告/"},{"title":"UVA12879 Golf Bot 解题报告","text":"大概是最优解。 题目链接(洛谷)UVA12879 Golf Bot 题意简述给你$n$个数，记为数组$A$，再给你$m$个数，记为数组$B$，求从$A$中任选两个数（可重复）相加至多可以得到多少个$B$中的数。 解题思想首先你得看懂题，很容易想到一个暴力思路，$O(n^2)$枚举$A$中的元素，然后相加，将得到的数打标记。再$O(n)$枚举$B$中的元素，判断有没有标记。总复杂度$O(n^2)$。 但是T了。 但是T了。 但是T了。 很显然我们需要一个更快的算法。考虑单项式乘法，两个单项式相乘，底数不变，指数相加。这启示我们把$A$数组元素放到指数上。我们不妨根据$A$数组的元素构造两个相同的多项式，确保每一个以$A$中元素为指数的项系数不为0。注意：其他项系数必须为0！。然后将这两个多项式相乘，就可以得到一个以符合题意的元素为指数的项的系数不为0，其余项系数都为0的多项式，将该数组与$B$数组比对一下统计答案就行了。 有人会问：多项式乘法不是$O(n^2)$的吗？ 我们有FFT啊。 乘法部分用FFT搞一下就行了。 总时间复杂度$O(n\\log n)$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define max(a, b) a &gt; b ? a : bnamespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 1e6 + 6;const double Pi = acos(-1.0);struct Complex { double x, y; Complex(double _x = 0, double _y = 0) {x = _x, y = _y;}};Complex operator + (const Complex &amp;a, const Complex &amp;b) {return Complex(a.x + b.x, a.y + b.y);}Complex operator - (const Complex &amp;a, const Complex &amp;b) {return Complex(a.x - b.x, a.y - b.y);}Complex operator * (const Complex &amp;a, const Complex &amp;b) {return Complex(a.x *b.x - a.y * b.y, a.x * b.y + a.y * b.x);}int ans, limit, tot, n, m;int r[N], B[N];Complex A[N];inline void swap(Complex &amp;a, Complex &amp;b) {Complex tmp = a; a = b, b = tmp;}inline void FFT(Complex *A, int type) { for(register int i = 0; i &lt; limit; i++) { if(i &lt; r[i]) swap(A[i], A[r[i]]); } for(register int mid = 1; mid &lt; limit; mid &lt;&lt;= 1) { Complex Wn(cos(Pi / mid), type * sin(Pi / mid)); for(register int R = mid &lt;&lt; 1, j = 0; j &lt; limit; j += R) { Complex w(1, 0); for(register int k = 0; k &lt; mid; k++, w = w * Wn) { Complex x = A[j + k], y = w * A[j + mid + k]; A[j + k] = x + y; A[j + mid + k] = x - y; } } }}inline void init() { for(register int i = 0; i &lt; limit; i++) A[i].x = A[i].y = r[i] = 0; ans = 0; limit = 1; tot = 0;}int main() { while(~scanf(\"%d\", &amp;n)) { init(); int MaxN = 0;//最大指数 A[0].x = 1; for(register int i = 1; i &lt;= n; i++) { int x = read(); A[x].x = 1; MaxN = max(MaxN, x); } m = read(); MaxN++; for(register int i = 1; i &lt;= m; i++) B[i] = read(); while(limit &lt;= (MaxN &lt;&lt; 1)) limit &lt;&lt;= 1, tot++; for(register int i = 0; i &lt; limit; i++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (tot - 1)); FFT(A, 1); for(register int i = 0; i &lt; limit; i++) A[i] = A[i] * A[i]; FFT(A, -1); for(register int i = 0; i &lt; limit; i++) A[i].x /= limit; for(register int i = 1; i &lt;= m; i++) { if((int)(A[B[i]].x + 0.5)) ans++; } write(ans); } return 0;}","link":"/2019/05/18/UVA12879-Golf-Bot-解题报告/"},{"title":"ToDoList","text":"犹豫，就会败北；果断，也是白给。 放弃，亦无宽慰；坚持，终于崩溃。 吨吨吨往下灌。 要学的芝士OI您可以下载OI知识树（Made By Zgjjj With Xmind），但是您需要先安装Xmind。 字符串 KMP（拖了多久了qaq） AC自动机 后缀数组 后缀自动机 DP 树上背包优化 状压DP 斜率优化 数据结构优化 数位统计DP 计数DP DDP（大概会了） 图论 2-SAT 基环树 差分约束 二分图 带权匹配 最小点覆盖 最大独立集 DAG最小点覆盖 网络流 Dinic ISAP HLPP 上下界网络流 最大权闭合子图 离线分治 整体二分 带权二分 CDQ分治 数学 Pollard’s Rho Polya定理 Miller-Rabin素数鉴定 高斯消元博弈 博弈 莫比乌斯反演 01分规 群论 搜索 啥都不会，啥都要学 数据结构 Splay LCT fhq Treap 莫队 可持久化Trie 可持久化线段树 动态图 树套树 休闲 CSS Node.js 搭OJ 咕掉的事情题目P1432 倒水问题（弃了，不想写） P3803 【模板】多项式乘法（FFT） P2713 罗马游戏（咕咕咕） P2774 方格取数问题 P4593教科书般的亵渎 P3834 【模板】可持久化线段树 1（主席树） P1099 树网的核 Things 多项式学习报告补锅 P3119 草鉴定Grass Cownoisseur写题解（完成啦！） LCT学习报告 DarkBZOJ3583 杰杰的女性朋友","link":"/2019/05/02/ToDoList/"},{"title":"Trie与01树 学习报告","text":"借着异或粽子的契机学了一下Trie(zgjjj:原来这玩意不止能搞字符串) 概述Trie，字典树，显而易见是一个数据结构。它是解决字符串问题不是这个的有力工具。 它的衍生物01树则可以很方便的处理异或和最大问题。 Trie这玩意很奇怪，不同于其他常见的数据结构，它的节点信息保存在数组下标中。 举个例子：trie[p][ch - 'a'] != 0代表字符ch存在于字典树，p是什么我们待会看。 插入字符串123456789inline void ins(char *s) { int p = 0; for(register int i = 0; s[i]; i++) { char ch = s[i] - 'a'; if(trie[p][ch] == 0) trie[p][ch] = ++tot; p = trie[p][ch]; } end[p] = 1;} 这里的p就是当前节点的编号， tot存储的则是子节点之一的编号。 end[p]记录当前字符串是否结束，若不维护则树上串的前缀会被错误的判为存在。 查询字符串是否存在123456789inline bool check(char *s) { int p = 0; for(register int i = 0; s[i]; i++) { char ch = s[i] - 'a'; p = trie[p][ch]; if(p == 0) return 0; } return end[p];} 注意判断该串是否完结。 01树思想和Trie相似，但是01串的节点信息只有0和1 我们将一个数进行二进制划分，从大到小考虑每一位，依次插入字典树，那么在寻找与已知串异或和最大的串，只需贪心地找与当前位相反的节点。 例题P4551 最长异或路径 树上统计，需要先dfs出到每个节点的异或和，然后将权值插入01树。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;algorithm&gt;using std::max;const int N = 300010;const int M = N &lt;&lt; 1;int head[N], ver[M], edge[M], nxt[M];int cnt = 0, tot = 0, p;int trie[N * 31][2], d[N], ans, n;inline void add(int x, int y, int z) { ver[++cnt] = y, edge[cnt] = z, nxt[cnt] = head[x], head[x] = cnt; ver[++cnt] = x, edge[cnt] = z, nxt[cnt] = head[y], head[y] = cnt;}inline void ins(int x, int p) { for(register int i = 1 &lt;&lt; 30; i; i &gt;&gt;= 1) { bool ch = x &amp; i; if(!trie[p][ch]) trie[p][ch] = ++tot; p = trie[p][ch]; }}inline int query(int x, int p) { int ans = 0; for(register int i = 1 &lt;&lt; 30; i; i &gt;&gt;= 1) { bool ch = x &amp; i; if(trie[p][ch ^ 1]) ans += i, p = trie[p][ch ^ 1]; else p = trie[p][ch]; } return ans;}void dfs(int x, int fa) { for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(y != fa) { d[y] = d[x] ^ z; dfs(y, x); } }}int main() { scanf(\"%d\", &amp;n); for(register int i = 1; i &lt; n; i++) { int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); add(x, y, z); } dfs(1, 0); for(register int i = 1; i &lt;= n; i++) { ins(d[i], p); } for(register int i = 1; i &lt;= n; i++) { ans = max(ans, query(d[i], p)); } printf(\"%d\", ans); return 0;}","link":"/2019/04/09/Trie与01树-学习报告/"},{"title":"UVA1482 Playing With Stones 解题报告","text":"不用SG函数的博弈题不是好博弈题！ 题目链接(洛谷)UVA1482 Playing With Stones 题意简述在每一个的回合内，他可以拿走至少一个石子，但不能超过石子所在堆的石子总数的一半。不能继续操作的游戏者输。给定局面求是否先手必胜。 解题思想类似于$Nim$游戏，我们尝试把SG函数搞出来。 手玩一下堆数为1的情况，可以发现SG函数的一个规律： 当$n$为偶数时，$SG(n) = \\frac{n}{2}$ 当$n$为奇数时，$SG(n) = SG(n / 2)$ 不难递归实现SG函数：int sg(int x) {return x % 2 == 0 ? x / 2 : sg(x / 2);} 讲一讲优化方法：奇数偶数判定及整数除以2都可以使用位运算加速。 整数除以2就不讲了，大概大家都知道。 对于奇数偶数判定，我们考虑一个数的二进制表示。 可以发现，一个数若是偶数，那么它的二进制表示下的最低位一定为0。 而奇数相反。 我们可以使用x &amp; 1取出x的最低位，然后判断是否为1就行了。 这是优化后的SG函数： int sg(int x) {return x &amp; 1 ? sg(x &gt;&gt; 1) : x &gt;&gt; 1;} 类似于$Nim$博弈，我们将每一堆的SG函数异或和一下，然后判断是否为0就可以得到解。 参考代码123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cctype&gt;#define int long longinline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w;}int sg(int x) {return x &amp; 1 ? sg(x &gt;&gt; 1) : x &gt;&gt; 1;}signed main() { int t = read(); while(t--) { register int n = read(); register int a, ans = 0; for(register int i = 1; i &lt;= n; i++) a = read(), ans ^= sg(a); if(ans) puts(\"YES\"); else puts(\"NO\"); } return 0;}","link":"/2019/06/07/UVA1482-Playing-With-Stones-解题报告/"},{"title":"位运算与二进制状态压缩 学习报告","text":"前言在计算机中，数据都使用二进制存储与操作。因此，学习位运算不仅可以优化我们的程序（使可读性–），还可以帮助我们理解程序运行中的种种表现，帮助我们更好的DEBUG（卡常） 学习资料：《进阶指南》 位运算算术位运算下面给出四种算术位运算： 与 或 非 亦或 and,&amp; or,| not,~ xor,^ 注意与和或运算与条件连接使用的与和或不同，非也从!变为~。 这些运算的意义不再赘述。 移位左移低位补0，高位越界舍弃。 对于左移操作，我们有： $${1&lt;&lt;n=2^n,n&lt;&lt;k=2^k\\times n}$$ 右移低位越界舍弃，高位以符号位补充。 对于右移操作，我们有：$${n&gt;&gt;k=\\lfloor{\\dfrac{n}{2^k}}\\rfloor}$$ 状压基本操作 操作 运算 取出n的第k位 (n&gt;&gt;k)&amp;1 取出n的第0~k-1位 n&amp;((1&lt;&lt;k)-1) n的第k位取反 n^(1&lt;&lt;k) n的第k位赋1 n|(1&lt;&lt;k) n的第k位赋0 n&amp;(~(1&lt;&lt;k)) 可以在脑中模拟一下，应该很好理解 成对变换对于一个偶数${n}$，我们有${n+1=n ; xor ;1}$ 同样的，对于一个奇数${n}$，我们有${n-1=n ; xor ;1}$ 运用滚动数组和邻接表存反图 lowbit1int lowbit(int x){return x&amp;-x;} 这是代码，作用为取出数$x$的最低位的1。 运用了二进制补码的相关知识。不再赘述 是树状数组的核心。 后记使用位运算可以显著优化运行时间，因此，在对程序可读性无重大影响的基础上，笔者会尽量使用位运算。","link":"/2019/02/26/位运算与二进制状态压缩-学习报告/"},{"title":"UVA1510 Neon Sign 解题报告","text":"这种题挺好玩的2333 题目链接(洛谷)UVA1510 Neon Sign 题意简述一个圆上有n个点，告诉你每个点与其它点的边的颜色（红或蓝），求颜色相同的边组成的三角形的个数。 解题思想考虑正难则反，不妨统计存在不同色的边的三角形的个数，再用总数减。 统计总数：$$Sum = C_n^3 = n\\times (n - 1)\\times (n - 2)/6$$ 统计不同色边三角形个数：不妨先钦定两条边颜色一定不同，那么对于任意颜色的第三条边，这个三角形一定是不符合条件的。 考虑每个点，由于每条边被两个点相连，所以我们可以在读入时统计每个点连接的蓝边b[i]与红边r[i]条数，求和后除以2. 即： $$Opp = \\frac{1}{2}\\sum b[i]\\times r[i]$$ 那么答案为：$$Ans = Sum - Opp = n\\times (n - 1)\\times (n - 2)/6 - \\frac{1}{2}\\sum b[i]\\times r[i]$$ 计算是$O(n)$的，读入是$O(n^2)$的，故总复杂度为$O(n^2)$ 参考代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;int a[1001], b[1001];int main() { int t; scanf(\"%d\", &amp;t); while(t--) { memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); int n; scanf(\"%d\", &amp;n); for(register int i = 1; i &lt; n; i++) { for(register int j = i + 1; j &lt;= n; j++) { int opt; scanf(\"%d\", &amp;opt); if(opt) a[i]++, a[j]++; else b[i]++, b[j]++; } } int sum = 0; for(register int i = 1; i &lt;= n; i++) sum += a[i] * b[i]; printf(\"%d\\n\", n * (n - 1) * (n - 2) / 6 - sum / 2); } return 0;} 十二省联考命题组提醒您： 数据千万条，清空第一条。 多测不清空，爆零两行泪。","link":"/2019/04/29/UVA1510-Neon-Sign/"},{"title":"图论模板","text":"放一些图论模板，其实是自己懒得写学习报告了 存储方式邻接表一般情况用邻接表存储，不封装为结构体，绝对不使用vector 1234int head[N], ver[M], edge[M], nxt[M], from[M], cnt;inline void add(int x, int y, int z) { from[++cnt] = x, ver[cnt] = y, edge[cnt] = z, nxt[cnt] = head[x], head[x] = cnt;} 邻接矩阵仅在传递闭包和有必要使用Floyd时使用 int f[N][N] = {}； 最短路单源spfa考虑到无构造数据时一定使用 123456789101112131415161718inline void spfa(int s) { memset(d, 0x3f, sizeof(d)); v[s] = 1; d[s] = 0; q.push(s); while(!q.empty()) { int x = q.front(); q.pop(); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(d[y] &gt; d[x] + z) { d[y] = d[x] + z; if(!v[y]) { v[y] = 1; q.push(y); } } } }} Dijkstra无负权边且spfa被卡时使用，绝不使用无Heap优化版本 123456789101112131415161718192021222324252627282930struct node { int post, dist; bool operator &lt; (const node &amp;lxl) const { return lxl.dist &lt; dist; }};priority_queue&lt;node&gt; q;inline void dijkstra(int s) { for(register int i = 1; i &lt;= n; i++) d[i] = INF; d[s] = 0; q.push((node){s, 0}); while(!q.empty()) { node tmp = q.top(); q.pop(); int x = tmp.post; if(v[x]) continue; v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(d[y] &gt; d[x] + z) { d[y] = d[x] + z; if(!v[y]) { q.push((node){y, d[y]}); } } } }} 多源Floyd$O(n^3)$，看数据范围或骗分使用。 1234567for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= n; j++) { for(register int k = 1; k &lt;= n; k++) { if(f[i][j] &gt; f[i][k] + f[k][j]) f[i][j] = f[i][k] + f[k][j]; } }} 传递闭包Floyd的衍生物，同样是$O(n^3)$ 1234567for(register int i = 1; i &lt;= n; i++) { for(register int j = 1; j &lt;= n; j++) { for(register int k = 1; k &lt;= n; k++) { f[i][j] |= f[i][k] &amp; f[k][j]; } }} LCAlg[]预处理预处理$lg[]$数组以做到$O(1)$查询。 12345inline void init() { for(register int i = 1; i &lt;= n ; i++) { lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i); }} 树连边虽然树是无向的，但是边不能加两次。 123inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;} 树上倍增1234567891011inline void dfs(int x, int fa) { d[x] = d[fa] + 1; f[x][0] = fa; for(register int i = 1 ; (1 &lt;&lt; i) &lt;= d[x] ; i++) { f[x][i] = f[f[x][i - 1]][i - 1]; } for(register int i = head[x] ; i ; i = next[i]) { if(fa == ver[i]) continue; dfs(ver[i], x); }} 在线询问123456789101112131415int lca(int x, int y) { if(d[x] &lt; d[y]) swap(x, y); while(d[x] &gt; d[y]) { x = f[x][lg[d[x] - d[y]] - 1]; } if(x == y) { return x; } for(register int i = lg[d[x]] - 1 ; i &gt;= 0 ; i--) { if(f[x][i] != f[y][i]) { x = f[x][i], y = f[y][i]; } } return f[x][0];} MSTKruskal太菜了只会Kruskal 基于并查集的算法 12345678910111213141516171819202122232425262728293031323334353637inline int find(int x){return fa[x]==x?x:find(fa[x]);}inline bool merge(int x,int y){ int xx=find(x),yy=find(y); if(xx!=yy){ fa[xx]=yy; return 1; } return 0;}struct node{ int x,y,w;}a[M];bool cmp(node a,node b){ return a.w&lt;b.w;}int main() { int n, m; scanf(\"%d%d\",&amp;n, &amp;m); for(register int i = 1; i &lt;= m; i++) { scanf(\"%d%d%d\",&amp;a[i].x,&amp;a[i].y,&amp;a[i].w); } for(register int i = 1; i &lt;= n; i++) fa[i] = i; for(int i=1;i&lt;=m;i++){ if(merge(a[i].x,a[i].y)){ ans+=a[i].w; cnt++; } if(cnt==n-1){ printf(\"%d\",ans); return 0; } } else ERR;//这里的ERR应给予宏定义，发出错误信号} TopSort加边时维护节点的度 常用于DAGDP和树形DP 123456789101112queue&lt;int&gt; q;q.push(n);while(!q.empty()) { int now = q.front(); q.pop(); for(register int i = head[now] ; i ; i = next[i]) { int to = ver[i]; //do something deg[to]--; if(deg[to] == 0) q.push(to); }} Tarjan求割点注意区分这里low[]的更新与缩点中low[]的更新。 low[x] = min(low[x], dfn[y]) 123456789101112131415inline void tarjan(int x, int rt) { dfn[x] = low[x] = ++tot; int son = 0; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y, rt); low[x] = min(low[x], low[y]); if(low[y] &gt;= dfn[x] and x != rt) cut[x] = 1; if(x == rt) son++; } low[x] = min(low[x], dfn[y]);//注意区别 } if(son &gt;= 2 and x == rt) cut[x] = 1; } 缩点同上，注意区别。 low[x] = min(low[x], low[y]); 1234567891011121314151617181920212223242526inline void tarjan(int x) { low[x] = dfn[x] = ++idx; s.push(x); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); } else if(vis[y]) { low[x] = min(low[x], low[y]); } } if(dfn[x] == low[x]) { int y; while(s.top()) { y = s.top(); s.pop(); p[y] = x; v[y] = 0; if(x == y) break; val[x] += val[y]; } }} wjyyy大爷: 欧拉路 此部分来自lewin的成长之路 定义欧拉路：欧拉路是指从图中任意一个点开始到图中任意一个点结束的路径，并且图中每条边通过的且只通过一次。 欧拉回路:欧拉回路是指起点和终点相同的欧拉路。 结论没什么模板，结论记一记： 存在欧拉路的条件: 1.无向连通图存在欧拉路的条件： 所有点度都是偶数，或者恰好有两个点度是奇数，则有欧拉路。若有奇数点度，则奇数点度点一定是欧拉路的起点和终点，否则可取任意一点作为起点。 2.有向连通图存在欧拉路的条件： 每个点的入度等于出度，则存在欧拉回路（任意一点有度的点都可以作为起点） 除两点外，所有入度等于出度。这两点中一点的出度比入度大，另一点的出度比入度小，则存在欧拉路。取出度大者为起点，入度大者为终点。","link":"/2019/04/02/图论模板/"},{"title":"小闹钟","text":"简介你从来没有玩过的船新版本 当前版本只支持倒计时(巨水 Source Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdlib&gt;#include&lt;windows.h&gt;#include&lt;iostream&gt;using namespace std;int main(){ int hour,second,minute; cout&lt;&lt;\"输入格式\\\"时 分 秒\\\"\"&lt;&lt;endl; cin&gt;&gt;hour&gt;&gt;minute&gt;&gt;second; if(minute==60&amp;&amp;second&gt;0) { cout&lt;&lt;\"Input error!\"&lt;&lt;endl; } else { if(minute&gt;60||second&gt;60) cout&lt;&lt;\"Input error!\"&lt;&lt;endl; else { for(int i=3600*hour+60*minute+second;i&gt;0;Sleep(1000),i--) { system(\"cls\"); if((minute)&lt;0) { hour-=1; minute=60; } if((second-1)&lt;0) { minute-=1; second=60; } if(second&lt;10&amp;&amp;minute&lt;10) { second--; cout&lt;&lt;hour&lt;&lt;\":0\"&lt;&lt;minute&lt;&lt;\":0\"&lt;&lt;second&lt;&lt;endl; } if(second&lt;10&amp;&amp;minute&gt;=10) { second--; cout&lt;&lt;hour&lt;&lt;\":\"&lt;&lt;minute&lt;&lt;\":0\"&lt;&lt;second&lt;&lt;endl; } if(second&gt;=10&amp;&amp;minute&lt;10) { second--; cout&lt;&lt;hour&lt;&lt;\":0\"&lt;&lt;minute&lt;&lt;\":\"&lt;&lt;second&lt;&lt;endl; } if(second&gt;=10&amp;&amp;minute&gt;=10) { second--; cout&lt;&lt;hour&lt;&lt;\":\"&lt;&lt;minute&lt;&lt;\":\"&lt;&lt;second&lt;&lt;endl; } } for(int i=10;i&gt;0;i--) { cout&lt;&lt;\"\\a\"&lt;&lt;endl; Sleep(1000); } } } return 0;}","link":"/2019/01/19/小闹钟/"},{"title":"字符串Hash 学习报告","text":"听julao xht的建议学了字符串哈希。 先挂一张图： 图源：xht 拍自《进阶指南》 简介意义如书中所说，字符串hash可以将任何字符串映射成一个非负整数的值，从而方便进行比较。 hash冲突指两个或多个不同的字符串被映射到同一个非负整数的情况。 流程如何求给定串的Hash值首先选取一个固定值P（最好是质数），我们可以把字符串看成一个P进制数，以此映射到一个非负整数的值上。 接着选取一个固定模数M，将上述P进制数模M意义下的值作为原字符串的Hash值。 通常，我们选取$2^{64}$作为模数，这样就可以使用unsigned long long 类型来储存原P进制数，在大于模数M时自动溢出，可避免低效取模运算。 如何处理hash冲突任何数据都无法避免Hash冲突 我们可以做的，只是尽可能减少冲突概率。 有以下几种做法： 在模数上对于P，我们可以选用P=131或P=13331。对于M，我们可以选用19260817 其他做法可以进行多组Hash，使用一个多元组储存不同hash的结果，在比对时逐次比对，可以有效降低Hash冲突。 对应字符串的操作设$F[s]$储存字符串$s$的Hash值，那么对于一个新串$t$，我们有 $${F[t]=(F[s+t]-F[s]*P^{strlen(t)})}$$ 对应到P进制数上，就相当于左移操作。 当$t$为一个字符${c}$时，我们可以得到字符串Hash值的初始化公式： $${F[s+c]=F[s]+p\\times value[c]}$$ 一般$value[c]$取$ASCII$码中字符c的对应值。 例题Luogu P3370 【模板】字符串哈希(这题${Set}$和${Map}$可以水过) CH1401 兔子与兔子","link":"/2019/02/14/字符串Hash-学习报告/"},{"title":"平摊分析 学习报告","text":"前言？ 在b站上看MIT的课学了这个玩意… 本来以为平摊分析与势能分析是两个玩意，看完之后发现自己太naive了。 问题引入 Hash表应该开多大？ 从时间上考虑 一般来说，Hash表开的越大，查找时间就越短，当一个Hash表足够大的时候，它就成了一个直接映射表，查找时间最差为$O(1)$ 从空间上考虑 我们希望它尽可能的小，这样就不会浪费空间。 综合考虑上述两点，我们得到一个折中值： 对于n个元素，Hash表的大小的最好的折中值为$\\Theta(n)$ 但是，如果我们不知道将要加入的元素个数呢？ 这个问题的解是动态表（Dynamic Tables） 当一个普通的Hash表溢出（Overflow）时，就增大空间。 （有点vector的感觉） 增大空间的方法？ 分配一个更大的表（malloc()），然后将元素从旧表迁移到新表，然后释放旧表的空间。（似乎非常的慢。） 假设有一个大小为1的空的Hash表。 这里我们不考虑Hash的过程，来直接模拟溢出及分配的过程： Operation Table Size Elements Insert(1) 1 1 Insert(2) 2 1 2 Insert(3) 4 1 2 3 Insert(4) 4 1 2 3 4 可以发现，表的扩张是倍增实现的 对此方法做分析： 有一个序列，包括n次插入运算，求最坏情况下，一次插入的代价？ 对于任何元素，最差的情况是在插入时，表会溢出，这时需要将旧表中的每一项都复制到新表中，所以在最差情况下，一次插入的代价为$\\Theta(n)$ 所以最差情况下，$n$次插入的总代价=$n \\times \\Theta(n) = \\Theta(n ^ 2)$ 你没发现上一句话没东西加粗嘛？ 因为它假了。 稍加观察可以发现，并不是每个元素在插入时都处在最差情况，实际上，最差情况下，n次插入的总代价依然是 $\\Theta(n)$ 简略证明：设第i次插入的代价为$c_i$ 由于扩张是倍增实现的，所以在插入第二的整数幂加一个整数时，表会发生扩张，此时插入的代价为$\\Theta ( n ) $ $$\\therefore c_i = \\begin{cases} i &amp; \\log_2(x - 1) \\in \\mathbb N \\ \\ 1 &amp; Otherwise\\end{cases}$$ 对每一项分析代价，列出如下表格： 项数 1 2 3 4 5 6 7 8 9 表的大小 1 2 4 4 8 8 8 8 16 插入代价 1 1 1 1 1 1 1 1 1 扩张代价 0 1 2 0 4 0 0 0 8 观察表的规律，对代价求和得： ​ 总代价 $=\\sum\\limits_{i = 1} ^ n c_i$ $= n + \\sum\\limits_{j = 0} ^{\\lfloor\\log_2(n - 1)\\rfloor} 2 ^ j$ 第二项是一个几何级数，上界由最大值决定，所以我们得到： $$\\sum\\limits_{j = 0}^{\\lfloor\\log_2(n - 1)\\rfloor} 2^j\\le 2n$$ 所以$n + \\sum\\limits^{\\lfloor\\log_2(n - 1)\\rfloor} _ {j = 0} \\le 3n = \\Theta(n)$ 所以总代价为$\\Theta(n )$ 所以每次插入的平均代价为$\\frac{\\Theta(n)}{n} = \\Theta(1)$ 这就是对Hash表插入操作的平摊分析 平摊分析特性由上面的例子我们很容易发现平摊分析的一个特性：尽管一个操作序列中，部分操作的代价可能比较大，但是对它的平摊分析表示这个操作序列中每个操作的平均代价很小。 这是最差情况下的平均表现，不涉及概率。 意义平摊分析给出了最坏情况下的整个操作序列的代价上界。 三种方法 聚集分析 正如上面的例子展现的方法。基本上是分析整个操作序列的花费时间，并不能轻易钦定某一个操作的时间复杂度。（例题是特殊情况） 记账方法 势能分析 下面两者更加精确，它们为每一个操作分配了特定的平摊代价。 回顾例题我们现在闲的蛋疼用后两种方法来分析分析。 记账方法还没看完咕咕咕咕咕…","link":"/2019/07/16/平摊分析-学习报告/"},{"title":"扩展欧几里得 学习报告","text":"预备知识取模运算数${a}$对数${b}$取模，等价于数${a}$减去数${a}$除以数${b}$向下取整的商乘上数${b}$的差（好绕啊）。 其实就是下面这个式子：$${a(mod;b){\\Longleftrightarrow}a-{\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor}\\times b}$$很好理解。 最大公约数数${a}$,${b}$的最大公约数指同时能够整除${a}$,${b}$的最大的正整数。记为 _gcd(a,b)_。 引子欧几里得定理原理又称辗转相除法，原理是这个式子：$${gcd(a,b)=gcd(b,a(mod ; b))}$$可以看出这个式子能够递归求解，递归边界为：$${b=0}$$ 证明${\\forall a,b 且a&gt;b}$ 若${b\\mid a}$ ，显然有${gcd(a,b)=b}$. 考虑${b\\nmid a}$： 不妨设${a=bk+c}$，显然有$a\\equiv c\\pmod{b}$. 设${d\\mid a}$且${d\\mid b}$，则${c=a-bk\\frac{c}{d}=\\frac{a}{d}-\\frac{b}{d}k}$ 故${d\\mid c}$. 故${\\forall c\\mid a}$且${c\\mid b}$，${c\\mid a(mod; b)}$. 反过来，设${d\\mid b}$ ${d\\mid a(mod; b)}$，同样有${\\frac{a;mod;b}{d}=\\frac{a}{d}-\\frac{b}{d}k\\frac{a;mod;b}{d}+\\frac{b}{d}k=\\frac{a}{d}}$. 故${d\\mid a}$. 故${gcd(a,b)=gcd(b,a(mod;b))}$. 代码实现1int gcd(int a,int b){return b?gcd(b,a%b):a;} 很简单，一行就够了。 扩展欧几里得用途解方程${ax+by=gcd(a,b)}$ 推导设${ax_1+by_1=gcd(a,b)}$. ······① ${bx_2+a(mod; b)y_2=gcd(b,a(mod; b))}$ ······② 由欧几里得定理：${gcd(a,b)=gcd(b,a(mod; b))}$ ······③ 由②③： ${bx_2+a(mod; b)y_2=gcd(a,b)}$ ······④ 由①④： ${ax_1+by_1=bx_2+a(mod;b)y_2}$ ······⑤ 由取模运算等价形式得： ${a(mod; b)=a-{\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor}\\times b}$ ······⑥ 由⑤⑥： ${ax_1+by_1=bx_2+({a-{\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor}\\times b})y_2}$ ······⑦ 由⑦移项得： ${ax_1+by_1=ay_2+b(x_2-{\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor}y_2)}$ ······⑧ 可得方程的一组可行解为： $\\begin{cases}{x_1=y_2}\\y_1=x_2-{\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor}y_2\\end{cases}$ ······⑨ 由⑨得：${\\forall x_n,y_n\\ne0}$，${\\begin{cases}x_n=y_{n+1}\\y_n=x_{n+1}-{\\left\\lfloor\\dfrac{a}{b}\\right\\rfloor}y_{n+1}\\end{cases}}$ ······⑩ 即每一个${x,y}$都可由上一层推出. 递归边界为：${b=0}$，此时，x=1，y=0. 代码实现12345void exgcd(int a,int b,int&amp; x,int &amp;y){ if(!b){x=1,y=0;return;} int g=exgcd(b,a%b,y,x);y-=a/b*x; return;} 典例题目链接：NOIP2012 同余方程推导过程不妨将题目中的${ax\\equiv 1\\pmod{b}}$转化为${ax+by=1}$. 若要求${x}$的最小正整数解，很显然，${y}$为负数. 由裴蜀定理：${ax+by=1}$有解，当且仅当${a,b}$互素. 那么，${gcd(a,b)=1}$. 求出了${gcd(a,b)}$，就可以运用exgcd来求解. 需要注意的是，${exgcd}$求出的只是一组可行解，需对解出的${x}$进行调整使其成为最小正整数解. 如何调整？ 仅需对x进行增减b的倍数的操作，使其恰大于0. 该操作可以简化为取模运算。 正确性可以这样理解： 因为${a,b}$互素，所以对于${x}$，对其增减任意倍数的${b}$，都能保证${b\\mid (1-ax)}$. 代码实现1234567891011121314#include&lt;cstdio&gt;long long a,b,x,y;void exgcd(long long a,long long b,long long&amp; x,long long &amp;y){ if(!b){x=1,y=0;return;} exgcd(b,a%b,y,x);y-=a/b*x; return;}int main(){ scanf(\"%lld %lld\",&amp;a,&amp;b); exgcd(a,b,x,y); printf(\"%d\",(x+b)%b); return 0;}","link":"/2019/02/10/扩展欧几里得算法/"},{"title":"排列与矩阵 部分知识点","text":"其实没那么难qwq 排列 定义 1（对换）：将交换一个排列中的任意两项称为对换 定义 2（逆序对数）：记$\\tau(A)$为排列$A$中的逆序对数 定义 3（奇偶性）：排列奇偶性为一个排列中逆序对数的奇偶性。 定理 1：对换导致排列奇偶性改变 证明： 对于相邻两项，显然成立。 对于任意$i, j$两项$(i &lt; j)$，可通过$2 \\times (i - j) - 1$次对换使得原$i, j$两项相邻，其余项相对位置不变。 定理 2：在全部的$n$阶排列中$(n \\ge 2)$，奇偶排列数量相同 证明： 法一：数学归纳法。 法二： 由定理 1：奇排列交换前两项可得偶排列。 故偶排列数量 $\\ge$ 奇排列数量 同理： 奇排列数量$\\ge$偶排列数量 故奇排列数量=偶排列数量 矩阵 定义 1（sgn）：定义$\\text{sgn}(j_1j_2…j_n) = (-1) ^ {\\tau(j_1j_2…j_n)}$ 定义 2（行列式）： 引理 1：行列交换，值不变 引理 2：用一个数乘行列式的某行等于用这个数乘此行列式 引理 3：如果行列式中某一行是两组数之和，则这个行列式等于两个行列式之和，这两个行列式分别以两组数为该行，而其余各行与原行列式对应各行相同 引理 4：对换行列式中两行的位置，行列式反号 引理 5：如果行列式中有两行成比例，则行列式等于0 引理 6：把一行的某个倍数加到另一行，行列式的值不变。 定义 3（零矩阵）： 定义 4（对角矩阵）：仅对角线上元素不为0的方阵，记作$\\text{diag}(c_1,c_2,c_3,…,c_n)$。 定义 5（纯量矩阵）：$\\text{diag}(c, c, c, … , c)$ 定义 6（单位矩阵）：$\\text{diag}(1, 1, 1, … , 1)$ 定义 7（上三角矩阵）：对角线下元素都为0的方阵 定义 8（下三角矩阵）：对角线上元素都为0的方阵 定义 9（对称矩阵）：对角线上下元素对称的方阵 定义 10（反对称矩阵）：对角线上下元素互为相反数的方阵（由定义：对角线上元素都为0） 定义 11（逆矩阵）：设$A$是$n$阶方阵，如果存在$n$阶方阵$B$使得$AB = BA = I$，则称$A$是可逆的（或者非奇异的），$B$是$A$的一个逆矩阵。否则称$A$是不可逆的（或者非奇异的） 定义 12（初等行（列）变换）： 以一个非0的数乘以某行 将某一行的$𝑘$倍加到另一行 互换两行 定义 13（初等变换矩阵）：单位矩阵$I$经过一次初等变换得到的矩阵 定义 14（矩阵相抵）：若矩阵$𝐵$可以由矩阵$𝐴$经过一系列初等变换得到，则称$𝐴$与$𝐵$相抵（等价），记做$𝐴≅𝐵$ 定义 15（余子式）：矩阵$A$任意删去一行及一列后得到的矩阵成为$A$的一个余子式，若删去$i$行$i$列，则得到$A$的一个主余子式。 定义 16（基尔霍夫矩阵）：定义：如果图$G$有总共$N$个点，那么图$G$的基尔霍夫矩阵$D$可以表示为： $D_{ii} = \\deg(i)$ $D_{ij} = -\\text{cnt}(i, j)$，其中$\\text{cnt}(i, j)$为点$i$至点$j$的路径数量。即为图$G$的度数矩阵减去邻接矩阵。 引理 1：$\\det(D)= 0$ 定理 1 ：$\\det(AB) = \\det(A)\\times \\det(B)$ 证明： 构造 引理 1：$\\det(\\prod\\limits_{i = 1}^sA_i) = \\prod\\limits_{i = 1}^s\\det(A_i)$ 引理 2：设$𝐴$为$𝑛$阶方阵，$𝐴𝑋=0$有非零解的充分必要条件是$𝐴$奇异 引理 3：设$𝐴$为$𝑛$阶方阵，若$\\exists B$为$𝑛$阶方阵，使得$𝐴𝐵=𝐼$(或$𝐵𝐴=𝐼$)，则$𝐴$可逆且$𝐴^{−1}=𝐵$ 引理 4：若$\\det(A) \\neq 0$，则$\\det(A^{-1}) = (\\det(A))^{-1}$ 引理 5（一些性质）： $(A^{-1})^{-1} = A$ $(AB)^{-1} = B^{-1}\\times A^{-1}$ $(kA)^{-1} = k^{-1}A^{-1}$ 定理 2：设$A$为$n$阶方阵，若$A$可逆，则线性方程组$AX =B$有唯一解$X = A^{-1}B$ 挺显然的，不证了。 定理 3：用初等变换矩阵左（右）乘矩阵$𝐴$，相当于对矩阵$𝐴$实行相应的初等行（列）变换 证明： 乘上单位矩阵 定理 4：初等变换矩阵都可逆 证明： 初等变换存在逆变换，故初等变换矩阵可逆 定理 5：相抵是一种等价关系 证明：略 定理 6（初等变换求逆）：构造$n \\times 2n$的矩阵$(AI)$，那么我们对$A$高斯消元，并将使用的初等变换矩阵左乘$(AI)$，这时取出$(AI)’$的右边，即为$A^{-1}$ 定理 7（矩阵树定理）：给定图$𝐺$，则图$𝐺$的生成树的个数等于其对应的基尔霍夫矩阵的主余子式的行列式。","link":"/2019/08/19/排列与矩阵-部分知识点/"},{"title":"最小生成树 学习报告","text":"预备知识生成树概念给定一张无向图${G{(V,E)}}$中，${(u,v)}$代表连接顶点${u,v}$的边，${w(u,v)}$代表此边的权重，我们称它的一个无环子集${G’(V,E’)}$ （注意这里的${V}$与母集的${V}$一致） 为图${G}$的一个生成树。 求法一张图的生成树可以通过任意顶点dfs寻得。 这里是代码： 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#define maxn 10010int map[maxn][maxn];bool vis[maxn];int n,m,u,v,w;void dfs(int x){ vis[x]=1; for(register int i=1;i&lt;=n;i++){ if(x==i) continue; if(!vis[i]&amp;&amp;map[i][x]){ printf(\"%d -&gt; %d : %d\\n\",x,i,map[x][i]); dfs(i); } }}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(register int i=1;i&lt;=m;i++){ scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); map[u][v]=w; map[v][u]=w; } dfs(1); return 0;} 注意：如果给定的图中存在一个环${C(V,E’)}$，即包含所有的顶点，那么此图的dfs生成树将会退化为链。 典例：如果我们对此图求dfs生成树 将会得到如下结果： 另:自己在考场上发现的（除了我都知道的）知识：对于树${T(V,E)},\\forall P \\in V$作为其根节点，都将得到一颗树${T’}$。 并查集又称用于多种不相交集合的数据结构 支持操作能够支持对于树的两种操作： 查询一棵树的根节点； 合并两棵树； 朴素代码12345678#define maxn 10010int fa[maxn];//维护父节点void init(int n){while(n--)fa[n]=n;}int find(int x){return fa[x]==x?x:find(fa[x]);}//递归实现查询void merge(int x,int y){ int xx=find(x);int yy=find(y); fa[xx]=yy;} 优化有路径压缩与按秩合并两种方法，这($zu\\grave{o}$)里($zh\\check{e}$)只($zh\\check{i}$)讲($hu\\grave{i}$)按秩合并：思想：用size[i]维护以${i}$为根节点的子树的大小，在合并时将小子树合并到大子树上。 代码123456789#define maxn 10010int fa[maxn],size[maxn];void init(int n){while(n--) fa[n]=n,size[n]=1;}int find(int x){return fa[x]==x?x:find(fa[x]);}void merge(int x,int y){ int xx=find(x);int yy=find(y); if(size[xx]&gt;size[yy]) std::swap(xx,yy); fa[xx]=yy;size[yy]+=size[xx];} 最小生成树简介MST（最小生成树），即为给定图的所有生成树中路径权值和最小的一个生成树。 求解有Prim和Kruskal两种算法。 下面将讲解Kruskal算法 克鲁斯卡尔算法介绍先将给定图的边按权值从小到大排序，然后利用并查集的思想，依次将权值最小的边的两个端点合并，保证了最小原则。在合并时，注意检查两颗子树是否隶属同一根节点，否则跳过，保证了无环原则。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define maxn 10010#define maxm 20010using std::sort;int fa[maxn];void init(int n){while(n--)fa[n]=n;}int find(int x){return fa[x]==x?x:find(fa[x]);}bool merge(int x,int y){ int xx=find(x);int yy=find(y); if(xx==yy) return 0; fa[xx]=yy; return 1;}struct node{ int x,y,w;}a[maxm];bool cmp(node a,node b){return a.w&lt;b.w;}int main(){ int n,m,ans=0,cnt=0; scanf(\"%d%d\",&amp;n,&amp;m); init(n); for(register int i=1;i&lt;=m;i++){ scanf(\"%d%d%d\",&amp;a[i].x,&amp;a[i].y,&amp;a[i].w); } sort(a,a+m,cmp); for(register int i=1;i&lt;=m;i++){ if(merge(a[i].x,a[i].y)){ ans+=a[i].w; cnt++; } if(cnt==n-1){ printf(\"%d\",ans); break; } } return 0;} 注意到一个性质边按权值从小到大排序，每次仅取出最小边，可以考虑用堆来维护（虽然被julao痛批但我一定要写上） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;queue&gt;#define maxn 10010#define maxm 20010using namespace std;struct node{ int x,y,w; bool operator &lt; (const node a)const{ return a.w&lt;w; }};priority_queue&lt;node&gt; q;int fa[maxn];void init(int n){while(n--) fa[n]=n;}int find(int x){return fa[x]==x?x:find(fa[x]);}bool merge(int x,int y){ int xx=find(x);int yy=find(y); if(xx==yy) return 0; fa[xx]=yy; return 1;}int main(){ int n,m,ans=0,cnt=0; scanf(\"%d%d\",&amp;n,&amp;m); init(n); for(register int i=1;i&lt;=m;i++){ node tmp; scanf(\"%d%d%d\",&amp;tmp.x,&amp;tmp.y,&amp;tmp.w); q.push(tmp); } for(register int i=1;i&lt;=m;i++){ node tmp=q.top(); q.pop(); if(merge(tmp.x,tmp.y)){ ans+=tmp.w; cnt++; } if(cnt==n-1){ printf(\"%d\",ans); break; } } return 0;} （这里的堆并没有起到优化的作用，相反常数比sort大一些，仅供喜欢堆的选手使用）","link":"/2019/02/11/最小生成树-学习报告/"},{"title":"树上问题杂谈","text":"本文将持续更新。 基环树找环的优秀做法思想鉴于基环树上的连通块能且仅能是环，我们固然可以使用Tarjan找出树上所有的强连通分量，但是Tarjan是$O(N + M)$的，而基环树上只有一个环，我们很容易发现，Tarjan复杂度偏高。下面介绍一种比较优秀的做法。 类似于匈牙利算法，我们使用一个返回值为bool值的dfs函数，在找到环的时候直接返回，这样可以剪去大量的遍历时间。但由于只有基环树符合这种仅有一个环的类型，这种做法也只仅限于基环树。 实现过程中通过类似于EK 算法的双向存边特性，使用pre[]数组维护了经过的边。 代码12345678910111213141516171819bool dfs(int x) { v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if((i ^ 1) == pre[x]) continue; pre[y] = i; if(v[y]) { printf(\"Circle: %d \", y); int now = x; while(now != y) { printf(\"%d \", now); now = ver[pre[now] ^ 1]; } return 1; } if(dfs(y)) return 1; } return 0;} 树的直径的几种求法方法两次搜索思想可以通过任意节点搜索，找出距离它最远的点，再以该节点为源点，找出与它距离最远的点，两次搜索找出的点即为直径的两端，前者到后者的距离即为树的直径。 正确性可以通过微扰法证明，我们尝试更改第一次搜索路径中的一个节点，使它到另一端的距离不再是最长的。 根据树的特性，两点间有且仅有一条简单路径，那么我们换成其它任何一个点时，它到直径另一个端点的距离总是较小的。这样一来，我们第一次找出的点就一定是直径的一个端点。 第二次搜索的证明相似。 代码只提供bfs的代码 123456789101112131415161718192021inline int bfs(int s) { for(register int i = 1; i &lt;= n; i++) d[i] = 0xcfcfcfcf, pre[i] = v[i] = 0; int ans = 0; d[s] = 0; queue &lt;int&gt; q; q.push(s); while(!q.empty()) { int x = q.front(); q.pop(); v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; d[y] = d[x] + z; pre[y] = i; q.push(y); } } for(register int i = 1; i &lt;= n; i++) if(d[ans] &lt; d[i]) ans = i; return ans;} 主函数中： 12int l = bfs(1);int r = bfs(l); 树上dp思想设计状态：D[x]表示以x为根的子树中的节点到x的最远距离 不难设计出转移方程： $D[x] =\\max\\limits_{i\\in son_x}{D[i] + edge(i, x)}$ 递归转移，过程中求解就好了。 代码12345678910void dp(int x) { v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i], z = edge[i]; if(v[y]) continue; dp(y); l2 = max(l2, d[y] + d[x] + z); d[x] = max(d[x], d[y] + z); }} 主函数中： 1dp(1); 优缺点分析两次搜索不适用于带负权边的树，但可以求出直径上具体的点。 而树上dp相反。 可以通过做这道题P3629 [APIO2010]巡逻来获得更深刻的理解。 这是题解 树哈希思想递归计算一颗树的Hash值。 需要注意题目中定义的同构的具体要求。 同时注意一下哈希冲突。 对复杂度无严格要求的情况下可以使用map&lt;&gt;有效避免哈希冲突。 例题及代码P5043 【模板】树同构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define ll unsigned long longusing namespace std;const int N = 100;const int M = N;const int base = 13331;int head[N], nxt[M], ver[M], cnt;int n, m;ll H[N][N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}ll Hash(int x, int fa) { vector &lt;ll&gt; h; ll res = N; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa) continue; h.push_back(Hash(y, x)); } sort(h.begin(), h.end()); for(register int i = 0; i &lt; h.size(); i++) { res *= base; res += h[i]; } return res * base + N + 1;}int main() { ios::sync_with_stdio(0); cin &gt;&gt; m; for(register int i = 1; i &lt;= m; i++) { cnt = 0; memset(head, 0, sizeof(head)); memset(nxt, 0, sizeof(nxt)); cin &gt;&gt; n; for(register int j = 1; j &lt;= n; j++) { int x; cin &gt;&gt; x; if(x != 0) add(j, x), add(x, j); } for(register int j = 1; j &lt;= n; j++) { H[i][j] = Hash(j, 0); } sort(H[i] + 1, H[i] + n + 1); for(register int j = 1, k = 0; j &lt;= i; j++) { while(k &lt;= n) if(H[i][++k] != H[j][k]) break; if(k &gt; n) {cout &lt;&lt; j &lt;&lt; endl; break;} } } return 0; 树上倍增求LCA思想倍增出$2^n$辈节点边号，通过双节点向上倍增查询。 二进制划分的思想：任何正整数都可以通过二的幂相加凑出。 代码预处理lg[]： 12345inline void init() { for(register int i = 1; i &lt;= n; i++) { lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i); }} 预处理距离： 123456789101112void dfs(int x, int fa) { d[x] = d[fa] + 1; f[x][0] = fa; for(register int i = 1; (1 &lt;&lt; i) &lt;= d[x]; i++) { f[x][i] = f[f[x][i - 1]][i - 1]; } for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa) continue; dfs(y, x); }} 查询LCA 12345678910111213inline int lca(int x, int y) { if(d[y] &gt; d[x]) swap(x, y); while(d[x] &gt; d[y]) { x = f[x][lg[d[x] - d[y]] - 1]; } if(x == y) return x; for(register int i = lg[d[x]]; i &gt;= 0; i--) { if(f[x][i] != f[y][i]) { x = f[x][i], y = f[y][i]; } } return f[x][0];} $To;Be;Continued…$","link":"/2019/06/06/树上问题杂谈/"},{"title":"Luogu P3406 海底高铁 解题报告","text":"题目链接:P3406 海底高铁题目分析:​ （第一眼以为是最短路） 这道题作为前缀和的练习挺不错的，因为它几乎不涉及其他算法。 ​ 首先根据题目中的信息进行数据读入：不开long long见祖宗（这题貌似不会） 123456789ll n,m,ans=0;//共N个城市,途经M个城市scanf(\"%lld%lld\",&amp;n,&amp;m);ll p[m+1];//访问顺序ll t[n+1]={};//经过次数,一定要初始化！ll a[n+1],b[n+1],c[n+1],x,y;//a[i]纸质单程票,b[i]办卡后的优惠价,c[i]办卡工本费for(ll i=1;i&lt;=m;i++) scanf(\"%lld\",&amp;p[i]);for(ll i=1;i&lt;=n-1;i++) scanf(\"%lld%lld%lld\",&amp;a[i],&amp;b[i],&amp;c[i]); ​ 由于第i段铁路连接了城市i和城市i+1，所以任意两个相邻的站点购买同种车票有且仅有一种费用，也就是说，价格仅与在某相邻两站之间的通过次数有关。此时，我们就将问题转化为求在给定路线下，每相邻两个站点路段的经过次数. ​ 那么，在出发之前，我们可以将每两站之间路段的经过次数全部初始化为0，然后，对每次给定的始发站和终到站，将其视作给定区间的两个端点，对此区间进行区间增操作。 如何进行区间增呢？？？首先这是给定的四个站点 ​ 如果我们按照1-3,3-2,2-4,4-3的顺序访问，可以发现四个站点间的路径经过次数是这样的： 路径 1-2 2-3 3-4 次数 1 3 2 ​ 一般的思路是，对于每个区间，用一个for对其所经次数++，然而我们发现，太慢了。 ​ 于是我们想到了前缀和： 对于每一个区间，我们可以在其左端点加上区间增的权值，再在右端点+1的位置减去区间增的权值，最后对该区间进行求前缀和操作。这样，我们可以得到一样的结果。 回到题目中​ 恍然大悟，对于每组给定的区间端点，也可以使用同样的方法。更方便地，我们可以在对所有区间端点处理完毕后，在进行求前缀和操作： 12345678910111213141516171819202122//由于给定的信息是端点（城市），但是要求的是区间（路段），所以循环次数应为城市数-1for(ll i=1;i&lt;=m-1;i++){ //对于端点的处理，要严格满足数学上的定义，小的在左端点，大的在右端点 //否则对于逆序信息，就相当于进行了区间减操作 if(p[i]&gt;p[i+1]){ x=p[i+1]; y=p[i]; } else{ x=p[i]; y=p[i+1]; } //上面的代码可以简写为: //x=min(p[i],p[i+1]); //y=max(p[i],p[i+1]); t[x]++;//左端点增 t[y]--;//右端点减}//求前缀和for(ll i=1;i&lt;=n;i++){ t[i]+=t[i-1];} ​ 最后，对于每一段路径，总价值加上该段路径费用的较小值。 12for(ll i=1;i&lt;=n-1;i++) ans+=min(a[i]*t[i],(b[i]*t[i]+c[i])); ​ 本题就解决啦！ 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define ll long long#define max(a,b) a&gt;b?a:b#define min(a,b) a&lt;b?a:busing namespace std;int main(){ ll n,m,ans=0; scanf(\"%lld%lld\",&amp;n,&amp;m); ll p[m+1]; ll t[n+1]={}; ll a[n+1],b[n+1],c[n+1],x,y; for(ll i=1;i&lt;=m;i++) scanf(\"%lld\",&amp;p[i]); for(ll i=1;i&lt;=n-1;i++) scanf(\"%lld%lld%lld\",&amp;a[i],&amp;b[i],&amp;c[i]); for(ll i=1;i&lt;=m-1;i++){ if(p[i]&gt;p[i+1]){ x=p[i+1]; y=p[i]; } else{ x=p[i]; y=p[i+1]; } t[x]++; t[y]--; } for(ll i=1;i&lt;=n;i++){ t[i]+=t[i-1]; } for(ll i=1;i&lt;=n-1;i++) ans+=min(a[i]*t[i],(b[i]*t[i]+c[i])); printf(\"%lld\",ans); return 0;}","link":"/2019/01/24/海底高铁/"},{"title":"Luogu P1616 疯狂的采药 解题报告","text":"题目链接:P1616 疯狂的采药题目分析：很明显的完全背包。 首先，我们先把这道题转化为标准完全背包： 各种草药 物品 草药的价值 物品的价值 草药的采摘时间 物品的质量 总采摘时间 背包容量 ok,那么这道题就变成了板子题。 我们先来设计状态： 设$$\\text{dp[i]为背包容量为i时，能放下的物品的最大价值}$$ $$\\text{t[j]与p[j]分别存储第j个物品的质量和价值}$$ 然后进行状态转移： 对于容量为k的背包，第m个物品，我们考虑： 如果放这件物品，那么k容量背包的价值为dp[k-t[m]]+p[m] 如果不放，那么k容量背包的价值仍为原始的dp[k] 根据数组dp的定义，我们可以得到状态转移方程: $$\\text{dp[k]=max(dp[k-t[m]]+p[m],dp[k])}$$ 同时，我们需要考虑该物品放入背包的先决条件： $$\\text{k-t[m]}\\ge\\text{0}$$ 考虑每一件物品，并且综合上面的条件,我们得到了代码： 1234567for(int i=1;i&lt;=T;i++){ dp[i]=0; //初始化，可通过将数组开在主函数外面省略这一步 for(int j=1;j&lt;=n;j++){ if(i-t[j]&gt;=0) dp[i]=max(dp[i],dp[i-t[j]]+p[j]) }} 问题所求的便是dp[T]。 Source Code1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::max;int main(){ int n,T; scanf(\"%d%d\",&amp;T,&amp;n); int t[n+1],p[n+1],dp[T+1]; for(int i=1;i&lt;=n;i++){ scanf(\"%d%d\",&amp;t[i],&amp;p[i]); } dp[0]=0; for(int i=1;i&lt;=T;i++){ dp[i]=0; for(int j=1;j&lt;=n;j++){ if(i-t[j]&gt;=0) dp[i]=max(dp[i],dp[i-t[j]]+p[j]) } } printf(\"%d\",dp[T]); return 0;}","link":"/2019/01/19/疯狂的采药/"},{"title":"矩阵快速幂 学习报告","text":"矩阵的存储为方便编写函数，我们使用一个结构体Mat来存储一个矩阵。 同时可以构造函数使矩阵元素的初始值为0。 1234struct mat { int m[N][N];//N视情况而定 mat(){memset(m,0,sizeof(m));}} 矩阵乘法定义对于大小为$n\\times m$的矩阵$A$和大小为$n\\times k$的矩阵$B$，规定$C=A\\times B$，其中：$$C_{i,j}=\\sum\\limits_{k=1}^{n}A_{i,p}*B_{p,j}$$ 代码实现1234567891011mat mul(mat a, mat b) { mat ans; for(register int i = 1 ; i &lt;= n ; i++) { for(register int j = 1 ; j &lt;= n ; j++) { for(register int k = 1 ; k &lt;= n ; k++) { ans.m[i][j] += a.m[i][k] * b.m[k][j]; } } } return ans;} 普通快速幂这里只给出实现。 123456789int power(int a, int b) { int ans = 1;//一定要记住初始值为1 while(b) { if(b&amp;1) ans = ans * a; a*=a; b&gt;&gt;=1; } return ans;} 矩阵快速幂意义常用于加速递推。 实现我们结合普通快速幂的思想，将元素换为矩阵，不难得到下面的代码： 123456789mat power(mat a, int b) { mat ans;//这里的ans已经初始化，具体看下文 while(b) { if(b&amp;1) ans = mul(ans, a); a = mul(a, a); b&gt;&gt;=1; } return ans;} 看到代码里的注释了🐎?矩阵$ans$同样是要初始化的，不同于普通快速幂，这里的$ans$应初始化为单位矩阵。（不知道是啥的，百度去吧）(应该没人不知道吧…)~~ 123for(register int i = 1 ; i &lt;= n ; i++) { ans.m[i][i] = 1;} 我们往往把它封装在init()里面，因为在数列递推问题中，要初始化的还有$base$矩阵。 不同的写法（打mul()太累了？），我们还可以在结构体内重载*和*=运算符。没什么大的区别。 123456789101112131415struct mat { int m[N][N]; mat(){memset(m,0,sizeof(m));} mat operator * (const mat &amp;a) const { mat ans; for(register int i = 1 ; i &lt;= n ; i++) { for(register int j = 1 ; j &lt;= n ; j++) { for(register int k = 1 ; k &lt;= n ; k++) { ans.m[i][j] += m[i][k] * a.m[k][j]; } } } return ans; }} 那么，快速幂中的mul()就要换成*。 关于数列加速递推构造矩阵我讲不来怎么构造 为了使用矩阵快速幂，我们需要构造一个矩阵base，使得每乘一次base，就可以得到数列的下一项。 需要注意我们在矩阵快速幂的时候，指数的值应当是n-2而不是n。 快在哪？快速幂O(logn)递推O(n)你说快在哪？ 一些需要注意的地方（感谢xht37帮我Debug…） 在可以模膜的地方都模一下，可以防止爆精度涨rp。 欧拉定理不能运用在矩阵快速幂中，模数是质数也不行（用在普通快速幂中也没觉得快多少？ 数据类型一定要一致不然会爆零 差不多就这些了。","link":"/2019/03/05/矩阵快速幂-学习报告/"},{"title":"Luogu P4316 绿豆蛙的归宿 解题报告","text":"手感太差了手写队列都能出锅 题目链接题目背景随着新版百度空间的上线，Blog宠物绿豆蛙完成了它的使命，去寻找它新的归宿。 题目描述给出一个有向无环图，起点为$1$终点为$N$，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果有$K$条离开该点的道路，绿豆蛙可以选择任意一条道路离开该点，并且走向每条路的概率为 $1/K$ 。 现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？ 输入输出格式输入格式：第一行: 两个整数 N M，代表图中有N个点、M条边第二行到第 1+M 行: 每行3个整数 a b c，代表从a到b有一条长度为c的有向边 输出格式：从起点到终点路径总长度的期望值，四舍五入保留两位小数。 输入输出样例输入样例#1： 4 41 2 11 3 22 3 33 4 4 输出样例#1： 7.00 说明对于20%的数据 N&lt;=100 对于40%的数据 N&lt;=1000 对于60%的数据 N&lt;=10000 对于100%的数据 N&lt;=100000，M&lt;=2*N 分析算是概率期望DP比较简单的一道了。 考虑目标状态：从起点走到终点的所经过的路径总长度期望。 可以使用数组DP[i]来表示点$i$到终点所经路径的总长度期望。 目标状态即为DP[1]。 定义点$i$出度为k，对于每一个与点$i$联通的顶点$j$，根据期望的定义不难得出状态转移方程：$$DP[i] = \\frac{1}{k}\\sum\\limits_{dist_{i,j}\\neq INF}(DP[j]+dist_{i,j})$$ 可以在对DAG拓扑排序的同时完成状态转移。 一些细节这道题挺坑的明明是自己太菜了 说一说写的过程中犯的一些错误。 关于存图因为从终点状态确定，所以需要从终点往起点转移。对应地，图也应该存反图。 我一直以为反图只能跑多源一汇Dijkstra想不到还有这用处 关于邻接表自己写的时候又犯了初学时的错误… 四个数组大小都是醒目的N（head[]大小确实是$N$ 然后就一直70pts… 评测居然报的不是RE 关于队列第一次交题的时候看到有一个点T了，就换了手写队列，加了快读。 然而我已经几百年没碰手写队列了… 先把代码放着： 123456789struct queue { int head, tail; int q[N]; inline void init() {head = tail = 0;} inline bool empty() {return head &gt; tail;} inline void push(int x) {q[++tail] = x;} inline void pop() {head++;} inline int front() {return q[head];}}; 第一遍写的时候，把empty()里面的&gt;写成了- 这样的话，当head&lt;tail时，返回值应该是false，但原写法却返回了true。 关于Top Sort需要开两个数组来保存节点的度，然后Top Sort的时候仅对一个做出更改。 不然要么你拓扑排序会炸，要么你算的期望会炸。 关于前向星遍历没什么好说的，我太菜了才能把i = next[i]打成i++ 细节差不多就这些。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;cctype&gt;const int N = 1e5 + 6;const int M = N &lt;&lt; 1;namespace FastIO { inline int read() { int r = 0 , w = 1; char ch = getchar(); while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } inline void write(int x) { if(x &lt; 0) putchar('-'); if(x &gt; 9) write(x / 10); putchar(x % 10 + '0'); } #define read() FastIO::read() #define write(x) FastIO::write(x)}struct queue { int head, tail; int q[N]; inline void init() {head = tail = 0;} inline bool empty() {return head &gt; tail;} inline void push(int x) {q[++tail] = x;} inline void pop() {head++;} inline int front() {return q[head];}};int edge[M] , ver[M] , next[M] , head[N] , cnt = 0;int out[N] , deg[N];int n, m;double dp[N];void Add(int x, int y, int z) { edge[++cnt] = z, ver[cnt] = y, next[cnt] = head[x], head[x] = cnt;}int main() { n = read() , m = read(); for(register int i = 1 ; i &lt;= m ; i++) { int x = read(), y = read(), z = read(); Add(y, x, z); out[x]++; deg[x]++; } queue q; q.init(); q.push(n); while(!q.empty()) { int now = q.front(); q.pop(); for(register int i = head[now] ; i ; i = next[i]) { int to = ver[i]; dp[to] += (dp[now] + edge[i]) / out[to]; deg[to]--; if(deg[to] == 0) q.push(to); } } printf(\"%.2f\",dp[1]); return 0;} 吐槽一下luogu的玄学评测，应该RE的问题，吸氧TLE，不吸氧WA。太真实了。","link":"/2019/03/14/绿豆蛙的归宿/"},{"title":"表达式树及三序表达 学习报告","text":"预备知识需要了解树的先序、中序、后序遍历 先来看一道题目 （源自洛谷有题） 这是2017年TG初赛试题，这篇文章主要讲述如何快速有效地解这一类题。 关于表达式的三序表达定义我们用一个例子来说明： 名称 表达式 中序表达式 $2\\times 3/(2-1)+3\\times(4-1)$ 前序表达式 $+/\\times23-21*3-41$ 后序表达式 $23\\times21-/341-\\times+$ 大致明白是什么了叭？ 意义有人问： 中序表达式这么方便，为什么还要开发看不懂的前序和后序表达式呢？ 原因很简单：中序表达式会使用括号 这将极大程度影响（机器）运算的效率。 那么，对于前序和后序表达式，即使是同样的式子与操作符，不同的优先级都将导致其表达式的不同。也就不存在引用括号的情况。 已知一个式子的中序表达，如何求它的前序和后序表达呢？也很简单。 引入一个概念： 表达式树我们来它长什么样： 这是表达式${(1+2)-(3\\times 4)}$的表达式树。 规定 表达式树的叶节点能且仅能为运算数 除叶节点外的节点全部为操作符 节点的深度与运算的优先级正相关 根据以上三点，可以得到一个中序表达式的表达式树。 转换通过这颗表达式树，我们很容易将中序表达式转化为等价的前序，后序表达式 如何转换？ 得到一个中序表达式后，我们先将它转化为一颗表达式树。 例如上面的$(1+2)-(3\\times 4)$ 转化后，对这棵树先序遍历，可以得到等价的前序表达式。 同样，对其后序遍历，可以得到等价的后序表达式。 这棵树的中序遍历，则是我们常用的中序表达式。","link":"/2019/02/13/表达式树及三序表达/"},{"title":"裴蜀定理 学习报告","text":"（这玩意真不难） 前置知识会$gcd$就行了。 定理$$\\forall a,b,x,y,d\\in Z,ax+by=d当且仅当gcd(a,b)\\mid d$$ 简要证明设$s=gcd(a,b)$，显然有$s\\mid a$且${s\\mid b}$ 又因为${x,y\\in Z}$，显然有$s\\mid ax$且${s\\mid by}$ 所以${s\\mid ax+by}$ 又因为${ax+by=d}$ 所以$s\\mid d$ 所以$gcd(a,b)\\mid d$ 推广 方程$ax+by=1$有解当且仅当$x,y$互素 对于给定数列${a}$,表达式$\\sum\\limits_{i=1}^na_ix_i&gt;0 $最小正整数值为${\\gcd\\limits_{1\\le i\\le n}{|a_i|}}$ 应用P4549 【模板】裴蜀定理 直接运用推广2求解就好，记得取${|a_i|}$ (说了很简单)","link":"/2019/02/13/裴蜀定理-学习报告/"},{"title":"贪心策略 学习报告","text":"大胆贪心，（不用）小心证明。——阮行止 简介定义贪心算法，本质上来讲不是一种算法，而是一种策略。其基本思路是在题解满足局部最优解将导致全局最优解时，每一次决策考虑且仅考虑当前最优解。 举个例子就拿天朝RMB面额的设计来讲，仅举元这一单位，分别有1元，5元，10元，50元，100元五种面额。为什么要这样设计呢？在日常的生活中，我们买东西时就会发现，对于任意一个价格的商品，我们在购买时，要想花费最少张数的RMB，只需永远花费当前小于等于商品面额的货币。这就是一种贪心策略。 例子的证明我太菜了不会证。 使用条件题意方面在定义中就提到过，要想使用贪心策略，一定要在题解满足局部最优解导致全局最优解。对于简单的贪心，你看题面就知道这是个贪心，而有技巧的贪心则需要自己的猜测与证明。 关于局部最优解局部最优解，即在当前局面看来，不考虑后续状态的情况下，结果最优的解。即是当前问题的一个子问题的最优解。 贪心的证明贪心策略是需要证明的，至于严谨性就看个人对于答案的确信程度和rp。 常用的方法微扰法个人至今都不是很会的一种方法。就是先假设一种贪心策略，再对该策略的局面做出所有可能的扰动（如交换相邻的两个元素），然后讨论扰动后的局面是否会造成更优的局面，若是，则原贪心策略被推翻；若对于所有的扰动局面，都有原贪心策略优于微扰后的策略，那么贪心成立。 解集分析法先枚举出小规模内的局面，若对于该规模问题，所有的解均能由同一种贪心策略取得，那么考虑该策略，扩大问题规模（有点像迭代加深搜索），将该策略取得的解与枚举的解对比，若成立，则策略极有可能成立。注意这里的极有可能，有些毒瘤数据可能刚好违背该策略，所以这是一种不严谨的方法。 数学方法我们先看个典例： 排队打水问题有n个人排队到r个水龙头去打水，他们装满水桶的时间t1、t2………..tn为整数且各不相等，应如何安排他们的打水顺序才能使他们总共花费的时间最少？ 好像前面两种方法都行不通了？其实我没试过我没来看一个黑科技： 排序不等式不等式的证明百科上讲的很清楚了，我就把结论挂在这吧：$$\\text{对于两个有序数组:$a_1\\le a_2\\le a_3\\le …\\le a_n$及$b_1\\le b_2\\le b_3\\le …\\le b_n$:}$$ $$\\sum\\limits_{i=1}^na_ib_i\\ge \\sum\\limits_{i=1}^na_ib_{j_i}\\ge\\sum\\limits_{i=1}^na_ib_{n+1-i} $$ $${通俗来讲，就是顺序和\\ge 乱序和\\ge 逆序和}$$ 那么，上面的例子就很好解决了吧？ 总是规划打水时间最短者先打，再计算总打水时间，就可以得到最优的打水时间。 总结正如阮行止所说,“太贪心了是要栽跟头的。”，贪心策略固可解决一部分题，但是，如果时时刻刻想着贪心，DP也写贪心，终究是得不到高分的。做人也正是如此吧。","link":"/2019/01/24/贪心策略-学习报告/"},{"title":"Luogu P2822 组合数问题 解题报告","text":"暴力能拿90（雾 题目题目描述组合数 ${C_n^m}$表示的是从${n}$ 个物品中选出${m}$个物品的方案数。举个例子，从 ${(1,2,3)}$三个物品中选择两个物品可以有 ${(1,2),(1,3),(2,3)}$这三种选择方法。根据组合数的定义，我们可以给出计算组合数${C_n^m}$的一般公式： $${C_n^m=\\frac{n!}{m!(n-m)!}}$$ 其中${n!=\\prod\\limits_{i=1}^ni}$；特别地，定义${0!=1}$。 小葱想知道如果给定${n,m}$和${k}$，对于所有的${0\\leq i\\leq n,0\\leq j\\leq \\min \\left ( i, m \\right )}$有多少对 (i,j)(i,j) 满足${C_i^j}$是${k}$的倍数。 输入输出格式输入格式：第一行有两个整数${t,k}$，其中代${t}$表该测试点总共有多少组测试数据，${k}$的意义见问题描述。 接下来${t}$行每行两个整数${n,m}$，其中${ n,m}$的意义见问题描述。 输出格式：共$t$行，每行一个整数代表所有的$0\\leq i\\leq n,0\\leq j\\leq \\min \\left ( i, m \\right )$中有多少对$(i,j)$满足$C_i^j$是$k$的倍数。 输入输出样例输入样例#1： 121 23 3 输出样例#1： 11 输入样例#2： 1232 54 56 7 输出样例#2： 1207 17 说明【样例1说明】 在所有可能的情况中，只有$C_2^1 = 2$是2的倍数。 【子任务】 分析30分做法照着题目打组合数公式。 优化的话，可以将阶乘打表，或者写INT_128将$C_{0\\le i\\le 2000}^{0\\le j \\le i}$打表 很无脑，没写代码。 50分做法打标算，多组数据输出不换行。 就像这样 70分做法发现需求出$C_{0\\le i\\le n}^{0\\le j\\le \\min(i,m)}$ 考虑组合数递推：$$ C^m_n=C^{m-1}_{n-1}+C^{m-1}_n$$ 可${O(mn)}$预处理。 但需要注意初始化，即递推起点：$${C_0^0=C_1^0=C_1^1=1}$$ 实现：123456789void build(){ c[0][0]=c[1][0]=c[1][1]=1; for(register int i=2;i&lt;=2000;i++){ c[i][0]=1; for(register int j=1;j&lt;=i;j++){ c[i][j]=(c[i-1][j-1]+c[i-1][j]); } }} 90分做法观察到多组数据模数一致，可以在预处理时取模。 实现：123456789void build(){ c[0][0]=c[1][0]=c[1][1]=1; for(register int i=2;i&lt;=2000;i++){ c[i][0]=1; for(register int j=1;j&lt;=i;j++){ c[i][j]=(c[i-1][j-1]+c[i-1][j])%k; } }} 100分做法观察到模数一致，考虑实现${O(1)}$查询：用前缀和维护一个答案数组ans[n][m]，在预处理组合数时进行维护。 注意容斥： 1ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1]; 注意对于当前数据的更新： 1if(!c[i][j]) ans[i][j]++; 注意答案传递：（想不明白可以画一个杨辉三角手玩） 1ans[i][i+1]=ans[i][i]; 对于100分的做法，需要注意到$Sample;2$：在$Sample; Input; 2$中，出现了$m&gt;n$的违法情况，对于这类数据，在答案输出时特判，输出ans[n][n] 代码1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#define ll long longinline ll min(ll a,ll b){return a&lt;b?a:b;}const int maxn = 2010;ll t,n,m,k,c[maxn][maxn],ans[maxn][maxn];inline void build(){ c[0][0]=c[1][0]=c[1][1]=1; for(register int i=2;i&lt;=2000;i++){ c[i][0]=1; for(register int j=1;j&lt;=i;j++){ c[i][j]=(c[i-1][j-1]+c[i-1][j])%k; ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1]; if(!c[i][j]) ans[i][j]++; } ans[i][i+1]=ans[i][i]; }}int main(){ scanf(\"%lld%lld\",&amp;t,&amp;k); build(); while(t--){ scanf(\"%lld%lld\",&amp;n,&amp;m); printf(\"%lld\\n\",m&gt;n?ans[n][n]:ans[n][m]); } return 0;} 注意事项这题坑不少，谈一谈作者实现时的问题： 对于$m=0$的数据，快读有锅，应换用标准输入输出； 多组数据题，输出时一定要换行！puts(&quot;&quot;);； 容斥和答案继承都是坑； 若非标算，在多组数据处理前应初始化ans； 目前没想到离线做法。","link":"/2019/02/13/组合数问题/"},{"title":"LCT 学习报告","text":"LCT是常数巨大的树剖 问题引入P4383 [八省联考2018]林克卡特树lct emmm，不是这个。 给你一棵树，有点权。 Subtask 1 询问x到y最短路径上的点权和。 这个简单，前缀和就好了。 Subtask 2 x到y最短路径上每个点点权加k 树上差分！ 我还会树剖！ Subtask 3 改变树的结构 emmmm… 由这个问题，我们提出了$LCT$。 定义、基本操作及原理我们先来回顾一下树剖。 在树剖中，我们使用线段树来维护链上的信息，其实也可以使用$Splay$的，但是它常数太大了，而且难写，没有必要。 考虑一下树剖的弊病：一旦一棵树确定了，它的重链也就确定了。 所以对于动态问题，树剖就没什么办法了。 这时需要用到$LCT$ 一些定义辅助树：以$Splay$作为辅助树，原树被划分成若干个$Splay$。 重儿子：重儿子与父亲节点同在一棵$Splay$中，一个节点最多只能有一个重儿子。 注意这里的重儿子的定义与树剖不同。 轻儿子：其他儿子。 重边：指向重儿子的边。 轻边：其他边。 重链：由重儿子连接构成的链。 轻链：其他链。 比如这是一棵树： 我们规定其中的一些节点为重儿子： 红色的是重儿子，蓝色的是轻儿子。 加粗的边为重边。 然后把它扭一扭（？），把$Splay$划分出来： 这棵$LCT$中的$Splay$被红笔圈了出来，为了满足$Splay$的性质，每棵$Splay$都在旋转后由轻边重新连接。 可以发现，对一棵$Splay$中序遍历，可以得到该$Splay$维护的重链自链顶向下访问的顺序。 在每条重链在一棵$Splay$上的同时，每个轻儿子单独构成一棵$Splay$。 同时，为了方便维护树的结构，我们将每棵$Splay$根的父亲节点设为该链链顶的父亲节点。 对比原树，我们发现，在此操作的过程中，一些边被断开，一些边被连上。 基本操作访问（Access）简介及原理LCT的核心操作。 顾名思义，访问就是从根节点出发，访问到某个节点。在访问的过程中，每个路径上的点都被设置为重儿子，即访问路径被设置为重链。 由于每个节点仅能有一个重儿子，所以我们访问路上的节点时，需要断掉它与之前的重儿子的连边，并加入到$Splay$中。 我们考虑自访问节点向根处理，对于访问到的每个节点，我们进行$Splay$操作，此时，其右子树即为原重链上需要断掉的一段。切断后，将节点右儿子设置为当前重儿子即可。 在LCT中，fa[x]记录全局父节点信息，与所在$Splay$无关，但是ch[x][i]记录的则是当前$Splay$的信息，因此，轻儿子不会被记录，我们只需要更改每个节点的右儿子信息，不需要更新右儿子的父节点信息。 代码实现1234567inline void access(int p) { for(register int q = 0; p; p = tr[p].fa) { splay(p); tr[p].ch[1] = q; upd(p); }} 换根（MakeRoot）简介及原理可以将某个节点设置为原树的根。 考虑如下性质： 对一棵$Splay$中序遍历，可以得到该$Splay$维护的重链自链顶向下访问的顺序。 在访问操作后，该节点至根的路径形成一条重链，我们将该节点$Splay$至根，此时，链顶节点即为原树的根，且该节点存在于链底，考虑$Splay$反转操作，即可将其转至链顶，即为原树根。 代码实现12345inline void makert(int p) { access(p); splay(p); reverse(p);} 找根（FindRoot）简介及原理找到原树的树根。 由于$LCT$可能维护了一个森林，所以有时候需要找到某个节点属于原森林中哪棵树。 考虑访问，此时自原树根节点到该节点的路径构成了一条重链，将该点伸展至根，此时链底即为原树根。 由于伸展操作，此时的$Splay$以深度为秩有序，所以最左的左儿子即为链底。 代码实现123456inline int findrt(int p) { access(p); splay(p); while(tr[p].ch[0]) p = tr[p].ch[0]; return p;} 分离树链（Split）简介及原理树链剖分 将原树中两节点间的简单路径分离出来。 考虑将两个节点间的简单路径构造为一条重链。 不妨先将树根设置为一个节点，并访问另一个，这样两个节点就在同一条重链上了。 此时再对访问的节点进行伸展操作，操作后的链表现为$Splay$的根及其左子树。 代码实现12345inline void split(int u, int v) { makert(u); access(v); splay(v);} 林克（Link）简介及原理连接两棵原树。 考虑在根与链底之间连轻边，因此我们需要将一个节点设为根，然后连在另一个节点上就行了。 代码实现1234inline void link(int u, int v) { makert(u); tr[u].fa = v;} 卡特（Cut）简介及原理切断原树。 考虑断除两个节点之间的重边。 先将边分离出来，然后切断父子关系即可。 如果左儿子不是$u$或者左儿子有右儿子，那么表示不存在$(u, v)$这条边。 代码实现12345inline void cut(int u, int v) { split(u, v); if(tr[v].ch[0] != u || tr[tr[v].ch[0]].ch[1]) return; tr[u].fa = tr[v].ch[0] = 0;} 树（Tree）没有这个东西 单点修改（Modify）简介及原理改变单点权值。 为避免更新操作带来的大常数（虽然本来常数就够大了），我们先将待修节点伸展至根，再进行修改。 代码实现123456inline void modify(int u, int w) { access(u); splay(u); tr[u].val = w; upd(u);} 判根（Isroot）简介及原理判断当前节点是否为一棵$Splay$的根。 上文中提到了ch[x][i]与fa[x]的差异性，我们可以利用这个差异来检查某个节点与父亲的连边是否为重边。 若不是重边，则ch[fa[x]][0] != x &amp;&amp; ch[fa[x]][1] != x 代码很自然。 代码实现123inline bool isroot(int x) { return tr[fa[x]].ch[0] != x &amp;&amp; tr[fa[x]].ch[1] != x;} 旋转（Rotate）简介及原理平衡树基操。 不过判断$Splay$根的方式有所改变，旋转的方式也有所改变。 主要是将判断爷爷节点是否存在改为判断父节点是否为根。 区别不大。 代码实现1234567891011inline void rotate(int p) { bool t = !isleft(p); int fa = tr[p].fa, ffa = tr[fa].fa; if(!isroot(fa)) tr[ffa].ch[!isleft(fa)] = p; // 这句一定要写在最前面 tr[fa].ch[t] = tr[p].ch[!t]; tr[p].ch[!t] = fa; tr[tr[fa].ch[t]].fa = fa; tr[p].fa = ffa; tr[fa].fa = p; upd(p), upd(fa); // 这里的upd(p)可以省略，但是upd(fa)绝对不能省，不放心可以都写上} 伸展（Splay）简介及原理$Splay$基操 反转标记的存在会使LCT出锅，所以Splay前要将标记下放至待伸展节点。 代码实现123456789101112131415161718192021222324252627282930313233343536373839//反转inline void reverse(int p) { swap(tr[p].ch[0], tr[p].ch[1]); tr[p].rev ^= 1;}//下放inline void pushdown(int p) { if(tr[p].rev) { if(tr[p].ch[0]) reverse(tr[p].ch[0]); if(tr[p].ch[1]) reverse(tr[p].ch[1]); tr[p].rev ^= 1; }}//手写栈可换为STL，也可递归调用函数int sta[MAXN], stop;//从根下放到p节点inline void pushto(int p) { stop = 0; while(!isroot(p)) { sta[stop++] = p; p = tr[p].fa; } sta[stop++] = p; while(stop) { pushdown(sta[--stop]); }}//伸展inline void splay(int p) { pushto(p); for(int fa = tr[p].fa; !isroot(p); rotate(p), fa = tr[p].fa) { if(!isroot(fa)) rotate(isleft(fa) == isleft(p) ? fa : p); } upd(p);} 应用直接运用操作及原理单点修改，动态加边、断边，保证结构是一棵树，查询两点间简单路径的信息。 用LCT直接维护即可。 例题1P3690 【模板】Link Cut Tree （动态树） 维护两点间最短路径的异或和即可。 比树剖板子题和蔼多了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;cstdio&gt;#include &lt;cctype&gt;#define LL long longnamespace FastIO { inline LL read() { char ch = getchar(); LL r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(LL x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(LL x) { _write(x); puts(\"\"); }}using namespace FastIO;template &lt;typename T&gt; inline void swap(T &amp;x, T &amp;y) {T tmp = x; x = y, y = tmp;}const int N = 300005;struct Node { int ch[2], fa, val, xsum; bool rev;} tr[N];inline bool isleft(int p) { return tr[tr[p].fa].ch[0] == p;}inline bool isroot(int p) { return tr[tr[p].fa].ch[0] != p &amp;&amp; tr[tr[p].fa].ch[1] != p;}inline void upd(int p) { tr[p].xsum = tr[p].val ^ tr[tr[p].ch[0]].xsum ^ tr[tr[p].ch[1]].xsum;}inline void reverse(int p) { swap(tr[p].ch[0], tr[p].ch[1]); tr[p].rev ^= 1;}inline void pushdown(int p) { if(tr[p].rev) { if(tr[p].ch[0]) reverse(tr[p].ch[0]); if(tr[p].ch[1]) reverse(tr[p].ch[1]); tr[p].rev ^= 1; }}int sta[N], stop;inline void pushto(int p) { stop = 0; while(!isroot(p)) { sta[stop++] = p; p = tr[p].fa; } sta[stop++] = p; while(stop) { pushdown(sta[--stop]); }}inline void rotate(int p) { bool t = !isleft(p); int fa = tr[p].fa, ffa = tr[fa].fa; tr[p].fa = ffa; if(!isroot(fa)) tr[ffa].ch[!isleft(fa)] = p; tr[fa].ch[t] = tr[p].ch[!t]; tr[tr[fa].ch[t]].fa = fa; tr[p].ch[!t] = fa; tr[fa].fa = p; upd(fa);}inline void splay(int p) { pushto(p); for(int fa = tr[p].fa; !isroot(p); rotate(p), fa = tr[p].fa) { if(!isroot(fa)) rotate(isleft(fa) == isleft(p) ? fa : p); } upd(p);}inline void access(int p) { for(int q = 0; p; q = p, p = tr[p].fa) { splay(p); tr[p].ch[1] = q; upd(p); }}inline void makert(int p) { access(p); splay(p); reverse(p);}inline int findrt(int p) { access(p); splay(p); while(tr[p].ch[0]) p = tr[p].ch[0]; return p;}inline void split(int u, int v) { makert(u); access(v); splay(v);}inline void link(int u, int v) { makert(u); tr[u].fa = v;}inline void cut(int u, int v) { split(u, v); if(tr[v].ch[0] != u || tr[u].ch[1]) return; tr[u].fa = tr[v].ch[0] = 0;}inline void modify(int u, int w) { access(u); splay(u); tr[u].val = w; upd(u);}int n, m, op, x, y;int main() { n = read(); m = read(); for(int i = 1; i &lt;= n; i++) { tr[i].val = tr[i].xsum = read(); } while(m--) { op = read(); x = read(); y = read(); switch(op) { case 0: split(x, y); write(tr[y].xsum); break; case 1: link(x, y); break; case 2: cut(x, y); break; case 3: modify(x, y); } } return 0;} 例题2P3203 [HNOI2010]弹飞绵羊 题目没有那么直白了，我们考虑建图。 观察到$k$仅能为正，考虑把每个点与它能抵达的所有点连边，这样就建成了一颗树。 对于可能跳过的情况，直接连接到一个超级汇点$n + 1$上。 建完图后，我们可以发现，每个点的答案即为它在以$n + 1$为根的有根树中的深度。 对于改$k$这个操作，我们发现连边的依据是$k$，那么这个操作相当于断旧边、连新边，考虑LCT。 此时我们再想想答案（即节点深度）怎么在LCT中体现。 对于每个被询问的点，不妨将它到$n + 1$节点的链$Split$出来，此时，这个节点的子树大小即为节点深度。 LCT维护即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;cstdio&gt;#include &lt;cctype&gt;#define LL long longnamespace FastIO { inline LL read() { char ch = getchar(); LL r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(LL x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(LL x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 200005;template &lt;typename T&gt; inline void swap(T &amp;x, T &amp;y) {T tmp = x; x = y, y = tmp;}template &lt;typename T&gt; inline T min(T a, T b) {return a &lt; b ? a : b;}struct Node { int ch[2], fa, sum; bool rev;} tr[N];inline bool isleft(int p) { return tr[tr[p].fa].ch[0] == p;}inline bool isroot(int p) { int fa = tr[p].fa; return tr[fa].ch[0] != p &amp;&amp; tr[fa].ch[1] != p;}inline void upd(int p) { int ls = tr[p].ch[0], rs = tr[p].ch[1]; tr[p].sum = tr[ls].sum + tr[rs].sum + 1;}inline void reverse(int p) { swap(tr[p].ch[0], tr[p].ch[1]); tr[p].rev ^= 1;}inline void pushdown(int p) { int ls = tr[p].ch[0], rs = tr[p].ch[1]; if(tr[p].rev) { if(ls) reverse(ls); if(rs) reverse(rs); tr[p].rev ^= 1; }}int sta[N], stop;inline void pushto(int p) { stop = 0; while(!isroot(p)) { sta[stop++] = p; p = tr[p].fa; } pushdown(p); while(stop) { pushdown(sta[--stop]); }}inline void rotate(int p) { bool t = !isleft(p); int fa = tr[p].fa, ffa = tr[fa].fa; tr[p].fa = ffa; if(!isroot(fa)) tr[ffa].ch[!isleft(fa)] = p; tr[fa].ch[t] = tr[p].ch[!t]; tr[tr[fa].ch[t]].fa = fa; tr[p].ch[!t] = fa; tr[fa].fa = p; upd(fa);}inline void splay(int p) { pushto(p); for(int fa = tr[p].fa; !isroot(p); rotate(p), fa = tr[p].fa) { if(!isroot(fa)) rotate(isleft(fa) == isleft(p) ? fa : p); } upd(p);}inline void access(int p) { for(int q = 0; p; q = p, p = tr[p].fa) { splay(p); tr[p].ch[1] = q; upd(p); }}inline void makert(int p) { access(p); splay(p); reverse(p);}inline int findrt(int p) { access(p); splay(p); while(tr[p].ch[0]) p = tr[p].ch[0]; return p;}inline void split(int u, int v) { makert(u); access(v); splay(v);}inline void link(int u, int v) { makert(u); tr[u].fa = v;}inline void cut(int u, int v) { split(u, v); if(tr[v].ch[0] != u || tr[tr[v].ch[0]].ch[1]) return; tr[u].fa = tr[v].ch[0] = 0;}int n, m, k[N], op, ut, wt;int main() { n = read(); tr[n + 1].sum = 1; for(int i = 1; i &lt;= n; i++) { k[i] = read(); tr[i].sum = 1; } for(int i = 1; i &lt;= n; i++) { int x = i, y = i + k[i]; y = min(y, n + 1); link(x, y); } m = read(); while(m--) { op = read(); ut = read() + 1; if(op == 1) { split(ut, n + 1); write(tr[n + 1].sum - 1); } else { wt = read(); cut(ut, min(ut + k[ut], n + 1)); k[ut] = wt; link(ut, min(ut + k[ut], n + 1)); } } return 0;} 处理子树信息操作及原理在树剖里，我们利用子树节点的dfs序的连续性建立线段树解决了子树信息的处理。 但是在LCT中，根是会变的，维护dfs序似乎并不靠谱。我们考虑直接维护子树的信息： 不妨对每一个点维护一个虚子树的信息，因为只有access()和link()会导致其改变，而cut()断开的是一条重边，不会影响一个虚子树的信息，所以只需要upd()一下就行了。 例题太菜了只找到了大融合。 P4219 [BJOI2014]大融合 首先考虑一条边的负载与什么有关。通过排列组合的知识我们可以知道，负载等于起点个数乘以终点个数。 起点个数与终点个数体现在树上就是断边后两个节点子树大小。 由于动态连边，我们要用LCT维护这个。 照着上面讲的做就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;const int N = 1e5 + 5;template &lt;typename T&gt; inline void swap(T &amp;x, T &amp;y) {T tmp = x; x = y, y = tmp;}struct Node { int ch[2], fa, tsz, sz; bool rev;} tr[N];inline void upd(int p) { tr[p].sz = tr[tr[p].ch[0]].sz + tr[tr[p].ch[1]].sz + tr[p].tsz + 1;}inline bool isleft(int p) { return tr[tr[p].fa].ch[0] == p;}inline bool isroot(int p) { return tr[tr[p].fa].ch[0] != p &amp;&amp; tr[tr[p].fa].ch[1] != p;}inline void reverse(int p) { tr[p].rev ^= 1; swap(tr[p].ch[0], tr[p].ch[1]);}inline void pushdown(int p) { if(tr[p].rev) { if(tr[p].ch[0]) reverse(tr[p].ch[0]); if(tr[p].ch[1]) reverse(tr[p].ch[1]); tr[p].rev ^= 1; }}int sta[N], stop;inline void pushto(int p) { stop = 0; while(!isroot(p)) { sta[stop++] = p; p = tr[p].fa; } sta[stop++] = p; while(stop) { pushdown(sta[--stop]); }}inline void rotate(int p) { bool t = !isleft(p); int fa = tr[p].fa, ffa = tr[fa].fa; tr[p].fa = ffa; if(!isroot(fa)) tr[ffa].ch[!isleft(fa)] = p; tr[fa].ch[t] = tr[p].ch[!t]; tr[tr[fa].ch[t]].fa = fa; tr[p].ch[!t] = fa; tr[fa].fa = p; upd(fa);}inline void splay(int p) { pushto(p); for(int fa = tr[p].fa; !isroot(p); rotate(p), fa = tr[p].fa) { if(!isroot(fa)) rotate(isleft(fa) == isleft(p) ? fa : p); } upd(p);}inline void access(int p) { for(int q = 0; p; q = p, p = tr[p].fa) { splay(p); tr[p].tsz += tr[tr[p].ch[1]].sz; tr[p].tsz -= tr[q].sz; tr[p].ch[1] = q; upd(p); }}inline void makert(int p) { access(p); splay(p); reverse(p);}inline int findrt(int p) { access(p); splay(p); while(tr[p].ch[0]) p = tr[p].ch[0]; return p;}inline void split(int u, int v) { makert(u); access(v); splay(v);}inline void link(int u, int v) { split(u, v); tr[u].fa = v; tr[v].tsz += tr[u].sz; upd(v);}inline void cut(int u, int v) { split(u, v); if(tr[v].ch[0] != u || tr[u].ch[1]) return; tr[v].ch[0] = tr[u].fa = 0;}int n, q;int main() { n = read(), q = read(); while(q--) { char op = getchar(); int x = read(), y = read(); if(op == 'A') link(x, y); else { split(x, y); write(tr[x].sz * (tr[y].sz - tr[x].sz)); } } return 0;} 太菜了把rotate()里的upd(fa)写成了upd(p)，调了好久，自己打自己脸qwq LCT动态加边求最大生成树操作及原理还没学会咕咕咕咕咕…","link":"/2019/07/15/LCT-学习报告/"},{"title":"多项式 学习报告","text":"看过期的luogu网课学会了多项式 前置知识多项式定义由常数及未知数通过有限次乘法、加法以及自然数幂次乘方的组合，得到的代数表达式。 本文仅讨论单元多项式。 简记记$f(x) = \\sum\\limits_{i=0}^{n-1}a_ix^i$为一个n-1次多项式。 其中该多项式的次数为n-1，记为${\\deg;f = n-1}$。 对于该多项式次数为i的一项，我们记$f(x)[i]$为该项的系数${a_i}$，简写为$f[i]$。 算术运算设$f(x)=\\sum\\limits_{i=0}^{n-1}{a_ix^i},g(x)=\\sum\\limits_{i=0}^{n-1}b_ix^i$ 加减法$$(f+g)(x)=\\sum\\limits_{i=0}^{n-1}(a_i+b_i)\\times x^i$$ $$(f-g)(x)=\\sum\\limits_{i=0}^{n-1}(a_i-b_i)\\times x^i$$ 卷积（多项式乘法）$$(f\\times g)(x)=\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{n-1}a_i b_j \\times x^{i+j}$$ 这个操作是$O(n^2)$的。 循环卷积$$(f \\times g)(x) = \\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{n-1}a_ib_j\\times x ^{[(i+j)(\\mod n)]} $$ 复数 代数基本定理：任何一元n次方程在复数域内都恰好有n个解 虚数单位定义$i=\\sqrt{-1}$，其中$i$被称为虚数单位。 复数复数集合符号为$\\mathbb{C}$，$\\mathbb{C}= { a+bi \\mid a,b\\in\\mathbb R } $ 对于一个复数$z=a+bi$: $a$被称为$z$的实部，记为$\\mathbf {Re(z)}$ $b$被称为$z$的虚部，记为$\\mathbf{lm(z)}$ 算术运算记$z_0,z_1\\in\\mathbb C,z_0=a_0+b_0i,z_1=a_1+b_1i$ 加减法$$z_0\\pm z_1=(a_0\\pm a_1)+(b_0 \\pm b_1)i$$ 乘法$$z_0\\times z_1 = (a_0a_1-b_0b_1)+(a_0b_1+a_1b_0)i$$ 可以将复数当成一个一次二项式来理解上面的式子。 复平面 复数$z=x+yi$与复平面上$(x,y)$一一对应。 $\\varphi$为幅角，那么可以得到复数的三角表示： $$z=r\\times (\\cos \\varphi+i\\sin \\varphi)$$ 欧拉定理$$e^{i\\varphi}=\\cos \\varphi + i\\sin \\varphi$$ 模长表示复平面内向量${\\vec z}$的模长，记为$\\left|{z}\\right|$ $$\\left|z\\right|=\\sqrt{a^2+b^2}$$ 共轭表示复平面内与$z$关于x轴对称的点，记为$\\bar z$ $$\\overline z=a-bi$$ 不难得到: $$\\overline zz=\\left|z\\right|^2$$ 共轭复数的四则运算都可以提取 $$\\overline{z_0\\pm z_1}=\\overline{z_0}\\pm\\overline{z_1}$$ $$\\lambda z=\\lambda a+\\lambda bi$$ $$\\overline{z_0\\times z_1}=\\overline{z_0}\\times \\overline{z_1}$$ $$\\frac{z_0}{z_1}=\\frac{z_0\\times \\overline {z_1}}{\\left|z_1\\right|^2}$$ 三角表示的复数乘法 此部分内容来自课件 回顾复数乘法公式$$z_0 \\times z_1 = (a_0a_1 + b_0b_1) + (a_0b_1 + a_1b_0) i$$，我们可以注意到$$\\mathbf{Re}(z_0 \\times z_1) = r_0 \\cos\\varphi_0 \\times r_1 \\cos\\varphi_1-r_0 \\sin\\varphi_0 \\times r_1 \\sin\\varphi_1 = r_0r_1 \\times \\cos(\\varphi_0 +\\varphi_1)$$，同时又有$$\\mathbf{Im}(z_0 \\times z_1) = r_0r_1 \\times \\sin (\\varphi_0 + \\varphi_1) $$。 尝试用三角表示改写乘法: $$(r_0 \\times e^{i\\varphi_0} ) \\times (r_1 \\times e^{i\\varphi_1} ) = (r_0 \\times r_1) \\times e^{i(\\varphi_0+\\varphi_1)}$$ 棣莫弗定理$$z_0z_1 = r_0r_1 \\times(cos(φ_0 + φ_1) + i \\sin(φ_0 + φ_1))$$ 即两复数相乘的结果，模长为两者之积，幅角为二者之和。 棣莫弗公式： $$z^n = r^n \\times (\\cos(n\\varphi) + i\\sin(n\\varphi))$$ 单位根满足方程$x^n = 1 $的所有的解，称为$n$次单位根。根据代数基本定理，$n$次方程在复数域内有$n$个解。 证明设$x=r\\times (\\cos \\varphi+i\\sin \\varphi )$，若$x$是$n$次单位根，则： $\\begin{cases}r^n=1\\\\cos (n\\varphi)=1\\\\sin(n\\varphi)=0\\end{cases}$ 推导过程：$\\qquad x^n=1$ $\\Rightarrow(r\\times (\\cos \\varphi+i\\sin \\varphi ))^n=1$ $\\Rightarrow(r^n\\times (\\cos n\\varphi+i\\sin n\\varphi))=1$ $\\Rightarrow \\sin n\\varphi = 1$ $\\Rightarrow \\varphi=0$ $\\Rightarrow \\cos n\\varphi = 1 $ $\\Rightarrow r^n=1$ $\\Rightarrow r= 1$ 那么，$r=1,\\varphi=\\frac{2\\pi+k}{n}， k\\in[0,n-1] 且 k\\in\\mathbb Z$恰好是$x^n=1$的$n$个不同的解。 结合单位圆 很容易得到$n$个单位根分别为$e^{\\frac{2k\\pi}{n}i},k\\in[1,n-1] 且 k\\in\\mathbb Z$ 记单位圆根$\\mathbf \\omega_n=e^{\\frac{\\omega\\pi}{n}i}$ 那么$n$个单位根又可以写成${\\mathbf \\omega_n^k},k\\in[1,n-1] 且 k\\in\\mathbb Z$ 性质 $\\mathbf \\omega_n^m=\\mathbf \\omega_{n/k}^{m/k}$ $\\mathbf \\omega_n^2=\\mathbf \\omega_{n/2}$ $\\mathbf \\omega_n^j=- \\mathbf \\omega_n^{j+n/2}$ )(可通过等比数列求和证明) $[n\\mid t]=\\frac{1}{n}\\sum\\limits_{j=0}^{n-1}\\mathbf \\omega_n^{tj}$(该性质是FFT的关键) 性质5中，[条件判断句1]运算符返回值为true当且仅当条件判断句1为真。 快速傅里叶变换 快速傅里叶变换(Fast Fourier Transform),即利用计算机计算离散傅里叶变换(DFT)的高效、快速计算方法的统称，简称FFT。快速傅里叶变换是1965年由J.W.库利和T.W.图基提出的。采用这种算法能使计算机计算离散傅里叶变换所需要的乘法次数大为减少，特别是被变换的抽样点数N越多，FFT算法计算量的节省就越显著。 来源：百度百科 推导记 $\\deg;f = \\deg ; g = n - 1 $，$f$与$g$的循环卷积为$h$ $\\qquad h[z]$ $\\quad =\\sum\\limits_{x=0}^{n-1} \\sum\\limits_{y=0}^{n-1}f[x]\\times g[y]\\times [n\\mid x+y-z]$ $\\quad =\\sum\\limits_{x=0}^{n-1} \\sum\\limits_{y=0}^{n-1}f[x]\\times g[y]\\times \\frac{1}{n}\\sum\\limits_{t=0}^{n-1}\\omega_n^{t(x+y-z)}$ $\\quad = \\frac{1}{n}\\sum\\limits_{t=0}^{n-1}\\omega_n^{-tz}(\\sum\\limits_{x=0}^{n-1}{f[x]\\times \\omega_n^{tx}})(\\sum\\limits_{y=0}^{n-1}g[y]\\times \\omega_n^{ty})$ 设$F[t] = \\sum\\limits {x=0} ^{n-1} f[x]\\times \\omega_n^{tx},G[t] = \\sum\\limits{y=0}^{n-1}g[x]\\times \\omega_n^{ty},H[t] = F[t]\\times G[t]$ 那么$h[t] = \\frac{1}{n}\\sum\\limits_{x=0}^{n-1}H[x]\\times \\omega_n^{-tx}$ 由$f,g$计算$F,G$的过程被称为离散傅里叶变换(Discrete Fourier Transform) 由$H计算h$的过程被称为离散傅里叶逆变换(Inverse Discrete Fourier Transform) 两者过程相差无几。 DFT现在仅考虑$n$为偶数的情况。 给定$f$，计算$F[t] = \\sum\\limits_{x=0}^{n-1}f[x] \\times \\omega _n^{tx}$。 设$f_a=f[2k],f_b=f[2k+1],k\\in\\mathbb N$ $$\\therefore F_a[t] = \\sum\\limits_{a=0}^{n/2-1}f_a[a]\\times \\omega _{n/2}^{ta}$$ $$\\therefore F_b[t] = \\sum \\limits_{b=0}^{\\ n/2-1}f_b[b]\\times \\omega_{n/2}^{tb}$$ 当$j&lt;n/2时$ $\\therefore F[j] = \\sum\\limits_{a=0}^{n/2-1}\\omega_n^{2a\\times j}f[2a]+\\sum\\limits_{b=0}^{n/2-1}\\omega_n^{(2b+1)\\times j}f[2b+1]$ $\\quad \\quad\\quad =\\sum\\limits_{a=0}^{n/2-1}\\omega_{n/2}^{a\\times j}f_a[a]+\\omega_{n}^j \\times \\sum\\limits_{b=0}^{n/2-1}\\omega _{n/2}^{b\\times j}f_b[b]$ $\\quad \\quad \\quad =F_a[j]+\\omega_n^jF_b[j]$ 当$j\\geqslant n/2$时 $\\therefore F[j+n/2]=\\sum\\limits_{a=0}^{n/2-1}\\omega_n^{2a\\times (j+n/2)}f[2a]+\\sum\\limits_{b=0}^{n/2-1}\\omega_n^{(2b+1)\\times (j+n/2)}f[2b+1]$ $\\quad \\quad \\quad \\quad \\quad \\ \\ =\\sum\\limits_{a=0}^{n/2-1}\\omega_{n/2}^{a}f_a[a]+\\omega_n^{j+n/2}\\times \\sum\\limits_{b=0}^{n/2-1}\\omega_{n/2}^{b}f_b[b]$ $\\quad \\quad \\quad \\quad \\quad \\ \\ =F_a[j]+\\omega_n^{j+n/2}F_b[j]$ $\\quad \\quad \\quad \\quad \\quad \\ \\ =F_a[j]-\\omega_n^jF_b[j]$ 计算出$F_a$与$F_b$后，可以$O(n)$得到$F$,而$F_a,F_b$的计算都是项数为$n/2$的DFT，我们仅需递归求解规模为原问题规模一半的子问题。 边界情况：n=1。 由主定理：DFT的时间复杂度为$T(n)=2T(n/2)+O(n) =O(n\\log n)$ IDFT与DFT区别不大，仅需将式中的$\\omega_n^{j}$修改为$\\omega _n ^{-j}$。","link":"/2019/03/07/多项式-学习报告/"},{"title":"树链剖分 学习报告","text":"众所周知，树链剖分是一个非常强的OIer（大雾 一些定义重儿子：子树最大的儿子节点 轻儿子：其他儿子节点 重链：由重儿子组成的链 轻链：其他链 原理及实现剖分结果首先这是一颗树 先不谈原理，直接将剖分后的树拿出来 其中加重的边构成重链，重儿子被染成红色，轻儿子被染成蓝色。 注意11与12号节点，他们的子树大小相同，此时我们仅将节点编号小的作为重儿子。 对着上面的两幅图可以更好的理解“重”的概念。 剖分过程我们通过两次dfs进行剖分。 规定变量123456/*默认邻接表存边*/sz[x] // 以x节点为根的子树大小d[x] // x节点的深度fa[x] // x节点的父节点son[x] // x节点的重儿子（注意是重儿子）tp[x] // x节点所在链的链顶 开始剖分第一遍dfs处理出每个节点的深度和子树大小，从而处理出每个节点的重儿子。 12345678910111213141516void dfs1(int x) { int maxx = -1; // 记录重儿子的子树大小以更新 for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x]) continue; d[y] = d[x] + 1; fa[y] = x; sz[x]++; dfs1(y); sz[x] += sz[y]; if(sz[y] &gt; maxx) { maxx = sz[y]; son[x] = y; } }} 第二遍dfs处理出每个节点所在链的链顶，注意这里的链仅指重链，规定轻链上每个点的链顶都为自己。 12345678910void dfs2(int x, int top) { tp[x] = top; //这里要优先遍历重儿子 if(son[x]) dfs2(son[x], top); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == son[x] || y == fa[x]) continue; dfs2(y, y); }} 至此，我们已经完成了树链剖分。 处理问题那么，树剖可以处理哪些问题呢？ 在线LCA考虑每条重链，根据定义，我们发现每个点若链顶相同，则LCA为深度较小的点。 可以结合上面的图理解一下。 有了这个性质，我们不妨尝试将每个点都转移到链顶相同的点，于是就有了下面的代码。 1234567inline int lca(int x, int y) { while(tp[x] != tp[y]) { if(d[tp[x]] &lt; d[tp[y]]) swap(x, y); x = fa[tp[x]]; } return d[x] &lt; d[y] ? x : y;} 复杂度为$O(\\log n)$ 例题：P3379 【模板】最近公共祖先（LCA）板子题，直接套上面的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;cctype&gt;namespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;template &lt;typename T&gt; inline void swap(T &amp;x, T &amp;y) {T tmp = x; x = y, y = tmp;}const int N = 5e5 + 6;const int M = N &lt;&lt; 1;int head[N], nxt[M], ver[M], cnt;int tp[N], sz[N], fa[N], son[N];int d[N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}void dfs1(int x) { int maxx = -1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x]) continue; d[y] = d[x] + 1; sz[x]++; fa[y] = x; dfs1(y); sz[x] += sz[y]; if(sz[y] &gt; maxx) { maxx = sz[y]; son[x] = y; } }}void dfs2(int x, int top) { tp[x] = top; if(son[x]) dfs2(son[x], top); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == son[x] || y == fa[x]) continue; dfs2(y, y); }}inline int lca(int x, int y) { while(tp[x] != tp[y]) { if(d[tp[x]] &lt; d[tp[y]]) swap(x, y); x = fa[tp[x]]; } return d[x] &lt; d[y] ? x : y;}int main() { int n = read(), m = read(), s = read(); for(register int i = 1; i &lt; n; i++) { int x = read(), y = read(); add(x, y); add(y, x); } dfs1(s); dfs2(s, s); for(register int i = 1; i &lt;= m; i++) { write(lca(read(), read())); } return 0;} 处理子树考虑一棵树的dfs序 dfs序用数组dfn[x]表示节点x的dfs序，即对根节点dfs时访问到它的顺序。 这个可以在dfs2()时维护： 12345678910void dfs2(int x, int top) { tp[x] = top; dfn[x] = ++idx; if(son[x]) dfs2(son[x], top); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == son[x] || y == fa[x]) continue; dfs2(y, y); }} 依然是剖分后的树，我们标记一下每个节点的dfs序： 可以发现，每个子树中的节点的dfs序是连续的。 我们用区间来表示一颗子树： 清楚多了。 可以发现每个节点区间的左端点为dfn[x]，右端点为dfn[x] + sz[x] - 1 这让我们联想到线段树 于是我们可以对整棵树建立一颗线段树，这样可以区间查询获得子树信息。 例题：P3384 【模板】树链剖分链的dfs序显然是连续的，同样放在线段树上就行了。 注意本题中子树大小将根节点计算入内，sz[x] 应初始化为1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;cstdio&gt;#include &lt;cctype&gt;#define LL long longnamespace FastIO { inline int read() { char ch = getchar(); int r = 0, w = 1; while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();} while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();} return r * w; } void _write(int x) { if(x &lt; 0) putchar('-'), x = -x; if(x &gt; 9) _write(x / 10); putchar(x % 10 + '0'); } inline void write(int x) { _write(x); puts(\"\"); }}using namespace FastIO;template &lt;typename T&gt; inline void swap(T &amp;x, T &amp;y) {T tmp = x; x = y, y = tmp;}const int N = 1e5 + 6;const int M = N &lt;&lt; 1;int n, m, r, p, ptn[N], w[N];// 线段树#define lson (o &lt;&lt; 1)#define rson (o &lt;&lt; 1) | 1#define mid ((l + r) &gt;&gt; 1)LL val[N &lt;&lt; 2], tag[N &lt;&lt; 2];inline void pushdown(int o, int l, int r) { if(tag[o]) { tag[lson] = (tag[lson] + tag[o]) % p; tag[rson] = (tag[rson] + tag[o]) % p; val[lson] = (val[lson] + tag[o] * (mid - l + 1) % p) % p; val[rson] = (val[rson] + tag[o] * (r - mid) % p) % p; tag[o] = 0; }}inline void upd(int o) { val[o] = (val[lson] + val[rson]) % p;}inline void build(int o, int l, int r) { if(l == r) { val[o] = w[ptn[l]]; return; } build(lson, l, mid); build(rson, mid + 1, r); upd(o);}inline void add(int o, int l, int r, int ll, int rr, LL v) { if(l &gt;= ll &amp;&amp; r &lt;= rr) { val[o] = (val[o] + v * (r - l + 1) % p) % p; tag[o] = (tag[o] + v) % p; return; } pushdown(o, l, r); if(ll &lt;= mid) add(lson, l, mid, ll, rr, v); if(rr &gt; mid) add(rson, mid + 1, r, ll, rr, v); upd(o);}inline LL squery(int o, int l, int r, int ll, int rr) { if(l &gt;= ll &amp;&amp; r &lt;= rr) { return val[o]; } pushdown(o, l, r); LL res = 0; if(ll &lt;= mid) res = (res + squery(lson, l, mid, ll, rr)) % p; if(rr &gt; mid) res = (res + squery(rson, mid + 1, r, ll, rr)) % p; return res;}// 树剖int head[N], nxt[M], ver[M], cnt;int fa[N], sz[N], d[N], tp[N], son[N], dfn[N], idx;inline void adde(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}void dfs1(int x) { sz[x] = 1; int maxx = -1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x]) continue; d[y] = d[x] + 1; fa[y] = x; dfs1(y); sz[x] += sz[y]; if(sz[y] &gt; maxx) { maxx = sz[y]; son[x] = y; } }}void dfs2(int x, int top) { dfn[x] = ++idx; ptn[dfn[x]] = x; tp[x] = top; if(son[x]) dfs2(son[x], top); for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == son[x] || y == fa[x]) continue; dfs2(y, y); }}inline void Addline(int x, int y, LL z) { while(tp[x] != tp[y]) { if(d[tp[x]] &gt; d[tp[y]]) { swap(x, y); } add(1, 1, n, dfn[tp[y]], dfn[y], z); y = fa[tp[y]]; } if(d[x] &gt; d[y]) swap(x, y); add(1, 1, n, dfn[x], dfn[y], z);}inline LL Queryline(int x, int y) { LL res = 0; while(tp[x] != tp[y]) { if(d[tp[x]] &gt; d[tp[y]]) { swap(x, y); } res = (res + squery(1, 1, n, dfn[tp[y]], dfn[y])) % p; y = fa[tp[y]]; } if(d[x] &gt; d[y]) swap(x, y); res = (res + squery(1, 1, n, dfn[x], dfn[y])) % p; return res;}inline void Addt(int x, LL z) { add(1, 1, n, dfn[x], dfn[x] + sz[x] - 1, z);}inline LL Queryt(int x) { return squery(1, 1, n, dfn[x], dfn[x] + sz[x] - 1);}int op, x, y, z;int main() { n = read(), m = read(), r = read(), p = read(); for(register int i = 1; i &lt;= n; i++) w[i] = read(); for(register int i = 1; i &lt; n; i++) { int x = read(), y = read(); adde(x, y); adde(y, x); } dfs1(r); dfs2(r, r); build(1, 1, n); while(m--) { op = read(); x = read(); if(op &lt;= 2) y = read(); if(op == 1 || op == 3) z = read(); switch (op) { case 1: Addline(x, y, z); break; case 2: write(Queryline(x, y)); break; case 3: Addt(x, z); break; case 4: write(Queryt(x)); break; } } return 0;}","link":"/2019/07/15/树链剖分-学习报告/"},{"title":"襄阳四中NOIP 2019 模拟赛","text":"dlwjyyy Day 1题面 签到（checkin）签到题没签上，写了个假dp，还好还有点分。 题目大意给定一些区间，要求求出它们的一个子集，使得这个集合的元素两两不交，最大化它们的并。 48分做法将区间按某一端点排序后直接dp。 设$dp[i]$为区间$[1, i]$的最大并。 状态转移方程为：$$dp[r_i] = \\max\\limits_{0\\le j &lt; l_i}dp[j] + (r_i - l_i + 1)$$ 时间复杂度$O(nm)$ 代码12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N = 2e5 + 6;inline int max(int a, int b) {return a &gt; b ? a : b;}int n, m, pnt;struct node {int l, r;} a[N];int dp[N], ans, maxx = 0;inline bool cmp(node a, node b) {return a.l &lt; b.l;}int main() { freopen(\"checkin.in\", \"r\", stdin); freopen(\"checkin.out\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); for(register int i = 1; i &lt;= m; i++) {scanf(\"%d%d\", &amp;a[i].l, &amp;a[i].r);} std::sort(a + 1, a + m + 1, cmp); for(register int i = 1; i &lt;= m; i++) { for(register int j = 0; j &lt;= a[i].l; j++) { dp[a[i].r] = max(dp[a[i].r], dp[j] + (a[i].r - a[i].l + 1)); ans = max(ans, dp[a[i].r]); } } printf(\"%d\\n\", ans); return 0;} 100分做法观察到只需要求前$i$天的最大值，我们可以动态维护$O(1)$查询。 时间复杂度$O(n)$ 代码123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int N = 2e5 + 6;inline int max(int a, int b) {return a &gt; b ? a : b;}int n, m, pnt;struct node {int l, r;} a[N];int dp[N], ans, maxx = 0;inline bool cmp(node a, node b) {return a.l &lt; b.l;}int main() { freopen(\"checkin.in\", \"r\", stdin); freopen(\"checkin.out\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); for(register int i = 1; i &lt;= m; i++) {scanf(\"%d%d\", &amp;a[i].l, &amp;a[i].r);} std::sort(a + 1, a + m + 1, cmp); for(register int i = 1; i &lt;= m; i++) { while(pnt &lt; a[i].l) maxx = max(maxx, dp[pnt]), pnt++; dp[a[i].r] = max(dp[a[i].r], maxx + a[i].r - a[i].l + 1); ans = max(ans, dp[a[i].r]); } printf(\"%d\\n\", ans); return 0;} 集合（gather）$dfs$和树剖斟酌了一下选了树剖，这样不用开距离数组。 然后查询$T$飞了，多个log。 题目大意给定一棵树，每次询问有多少个点到给定两个点的距离相同。 40分做法dfs求距离，然后$O(n)$枚举每个点累加答案，时间复杂度$O(n ^ 2 + nq)$ 距离数组开不下。 傻逼快读出锅了，也不知道什么原理，Day2不敢用了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;const int N = 20010;const int M = N &lt;&lt; 1;int n, m;int head[N], nxt[M], ver[M], cnt;bool v[N];int d[N][N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}void dfs(int x, int s) { v[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(v[y]) continue; d[s][y] = d[s][x] + 1; dfs(y, s); }}int main() { freopen(\"gather.in\", \"r\", stdin); freopen(\"gather.out\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); for(register int i = 1; i &lt; n; i++) { register int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); } for(register int i = 1; i &lt;= n; i++) { memset(v, 0, sizeof(v)); dfs(i, i); } for(register int i = 1; i &lt;= m; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); register int ans = 0; for(register int i = 1; i &lt;= n; i++) { if(d[i][x] == d[i][y]) ans++; } printf(\"%d\\n\", ans); } return 0;} 100分做法树上倍增找到查询链的终点，然后用子树大小解决询问。 时间复杂度$O(q\\log n )$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N = 2e5 + 6;const int M = N &lt;&lt; 1;template &lt;typename T&gt; inline void swap(T &amp;a, T &amp;b) {T tmp = a; a = b, b = tmp;}int n, m;int head[N], nxt[M], ver[M], cnt;inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;}int d[N], fa[N], sz[N];int f[N][22];void dp(int x) { sz[x] = 1; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(y == fa[x]) continue; fa[y] = x; d[y] = d[x] + 1; f[y][0] = x; dp(y); sz[x] += sz[y]; }}inline void prework() { for(register int j = 1; j &lt;= 20; j++) { for(register int i = 1; i &lt;= n; i++) { f[i][j] = f[f[i][j - 1]][j - 1]; } }}int main() { freopen(\"gather.in\", \"r\", stdin); freopen(\"gather.out\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); for(register int i = 1; i &lt; n; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); } f[1][0] = 1; d[1] = 1; dp(1); prework(); for(register int i = 1; i &lt;= m; i++) { register int ans = 0; int x, y; scanf(\"%d%d\", &amp;x, &amp;y); if(abs(d[x] - d[y]) &amp; 1) puts(\"0\"); else if(d[x] == d[y]) { if(x == y) printf(\"%d\\n\", n); else { for(register int i = 20; i &gt;= 0; i--) { if(f[x][i] != f[y][i]) { x = f[x][i]; y = f[y][i]; } } register int lca = f[x][0]; for(register int i = head[lca]; i; i = nxt[i]) { if(ver[i] != x &amp;&amp; ver[i] != y &amp;&amp; ver[i] != f[lca][0]) { ans += sz[ver[i]]; } } ans += n - sz[lca]; printf(\"%d\\n\", ans + 1); } } else { int xx = x, yy = y; if(d[x] &lt; d[y]) {swap(x, y); swap(xx, yy);} for(register int i = 20; i &gt;= 0; i--) { if(d[f[x][i]] &gt;= d[y]) x = f[x][i]; } register int lca; if(x == y) lca = x; else { for(register int i = 20; i &gt;= 0; i--) { if(f[x][i] != f[y][i]) { x = f[x][i]; y = f[y][i]; } } lca = f[x][0]; } int dis = (d[xx] + d[yy] - (d[lca] &lt;&lt; 1)) &gt;&gt; 1; for(register int i = 20; i &gt;= 0; i--) { if((1 &lt;&lt; i) &lt; dis) { dis -= (1 &lt;&lt; i); xx = f[xx][i]; } } int ffa = f[xx][0]; for(register int i = head[ffa]; i; i = nxt[i]) { if(ver[i] != xx &amp;&amp; ver[i] != f[ffa][0]) { ans += sz[ver[i]]; } } printf(\"%d\\n\", ans + 1); } } return 0;} 混乱（mess）推了个规律出来，拍了一下大概是对的。 std还没写。 题目大意给出一个长为$n$的排列${a_i}$，定义混乱度为$\\sum\\limits_{i = 1}^{n} |a_i - i|$求有多少个混乱度为${k}$的排列。 Day 2题面 斗地主（landlords）没往图论上想，又签到失败。 题目大意给定$n$张卡牌，每张卡牌有正反两面${t_i}$和${b_i}$。每次选两张卡${x, y}$，得分为$\\min \\left(t_{x} \\oplus b_{y}, t_{y} \\oplus b_{x}\\right)$，然后删掉一张。求最大得分。 40分做法鈤wjyyy的课件上没写这个做法。 考场上xjb想出来的。 考虑状压dp 设$dp[S]$为当前剩下的牌状态为$S$时的最大得分。 然后一个状态$S$可以向删去某张牌后的状态转移。 状态转移方程不好写，不写了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#ifdef DEBUG#undef DEBUG#endifconst int N = 21;inline int max(int a, int b) {return a &gt; b ? a : b;}inline int min(int a, int b) {return a &lt; b ? a : b;}int dp[1 &lt;&lt; N];int a[N], b[N];int n;int main() { freopen(\"landlords.in\", \"r\", stdin); freopen(\"landlords.out\", \"w\", stdout); scanf(\"%d\", &amp;n); for(register int i = 1; i &lt;= n; i++) scanf(\"%d%d\", &amp;a[i], &amp;b[i]); for(register int s = (1 &lt;&lt; n) - 1; s &gt;= 1; s--) { for(register int i = 1; i &lt; n; i++) { for(register int j = i + 1; j &lt;= n; j++) { if(((s &gt;&gt; (i - 1)) &amp; 1) &amp;&amp; ((s &gt;&gt; (j - 1)) &amp; 1)) { #ifdef DEBUG printf(\"i = %d, j = %d\\n\", i, j); printf(\"this = \"); for(register int k = n; k &gt;= 1; k--) printf(\"%d\", s &gt;&gt; (k - 1) &amp; 1); puts(\"\"); printf(\"goal1 = \"); for(register int k = n; k &gt;= 1; k--) printf(\"%d\", (s - (1 &lt;&lt; (i - 1))) &gt;&gt; (k - 1) &amp; 1); puts(\"\"); printf(\"goal2 = \"); for(register int k = n; k &gt;= 1; k--) printf(\"%d\", (s - (1 &lt;&lt; (j - 1))) &gt;&gt; (k - 1) &amp; 1); puts(\"\"); printf(\"choice1 = a[%d] ^ b[%d] = %d ^ %d = %d\\n\", i, j, a[i], b[j], a[i] ^ b[j]); printf(\"choice2 = a[%d] ^ b[%d] = %d ^ %d = %d\\n\", j, i, a[j], b[i], a[j] ^ b[i]); #endif dp[s ^ (1 &lt;&lt; (i - 1))] = max(dp[s ^ (1 &lt;&lt; (i - 1))], dp[s] + min(a[i] ^ b[j], a[j] ^ b[i])); dp[s ^ (1 &lt;&lt; (j - 1))] = max(dp[s ^ (1 &lt;&lt; (j - 1))], dp[s] + min(a[i] ^ b[j], a[j] ^ b[i])); #ifdef DEBUG printf(\"dp[goal1] = %d\\n\", dp[(s ^ (1 &lt;&lt; (i - 1)))]); printf(\"dp[goal2] = %d\\n\", dp[(s ^ (1 &lt;&lt; (j - 1)))]); puts(\"\"); #endif } } } } #ifdef DEBUG for(register int i = (1 &lt;&lt; n) - 1; i &gt; 0; i--) { printf(\"dp[\"); for(register int j = n; j &gt;= 1; j--) printf(\"%d\", i &gt;&gt; (j - 1) &amp; 1); printf(\"] = \"); printf(\"%d\", dp[i]); puts(\"\"); } #endif int ans = 0; for(register int i = 1; i &lt;= n; i++) { ans = max(ans, dp[1 &lt;&lt; (i - 1)]); } printf(\"%d\", ans); return 0;} 100分做法一共会删$n - 1$次，然后有$n$个状态，所以可以建图跑最大生成树。 边数大，用$Kruskal$会被卡，所以选择$Prim$ 代码还没写 随机（random） 要用魔法对抗魔法。 —- Zech大爷 所以我写了随机数膜随机数。 题目大意给定一个$01$串，每次获得一个范围在当前长度的随机整数，共$m$次，算期望删掉$0$的个数。 100分做法状压dp，然后状态有前导0，单独记串长空间会炸，可以在串前记一个标记1。 代码还没写 仙人掌（tree）数 据 分 治 题目大意给定一个$n$个节点，$m$条边的图，如果删掉一个点后，图变成了一棵树，那么就称这个点为仙人掌节点。找到所有的仙人掌节点，答案升序输出。 其实是UOJ原题 30分做法暴力删点判树。 $$O(n ^ 2)$$ 代码不放了，写法多。 树的情况叶子节点计数。 基环树的情况先找环，删掉环上度数为2的点。 这几档打完大概65分。 100分做法首先割点一定不是“仙人掌点”。 然后对于剩下的点，我们考虑删去它的影响：剩下的图只有$n - 1$个节点，要使它成为树，则需剩下$n - 2$条边。 读入时记录一下点的度，判一下是否等于$m - (n - 2)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;using namespace std;const int N = 2e5 + 6;const int M = N &lt;&lt; 1;inline int min(int a, int b) {return a &lt; b ? a : b;}inline int max(int a, int b) {return a &gt; b ? a : b;}int n, m;int head[N], nxt[M], ver[M], low[N], dfn[N], in[N], ans[N], cnt, rt, idx, num;bool cut[N];inline void add(int x, int y) { ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt; ver[++cnt] = x, nxt[cnt] = head[y], head[y] = cnt; in[x]++, in[y]++;}void tarjan(int x) { dfn[x] = low[x] = ++idx; int son = 0; for(register int i = head[x]; i; i = nxt[i]) { int y = ver[i]; if(!dfn[y]) { tarjan(y); low[x] = min(low[x], low[y]); if(low[y] &gt;= dfn[x]) { son++; if(x != rt || son &gt; 1) cut[x] = 1; } } else low[x] = min(low[x], dfn[y]); }}int main() { freopen(\"tree.in\", \"r\", stdin); freopen(\"tree.out\", \"w\", stdout); scanf(\"%d%d\", &amp;n, &amp;m); for(register int i = 1; i &lt;= m; i++) { register int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); } for(register int i = 1; i &lt;= n; i++) { if(!dfn[i]) tarjan(i); } for(register int i = 1; i &lt;= n; i++) { if(cut[i] == 0 &amp;&amp; in[i] == m - n + 2) { num++; ans[num] = i; } } printf(\"%d\\n\", num); for(register int i = 1; i &lt;= num; i++) printf(\"%d \", ans[i]); return 0;} 总结挂了很多分很烦。 有些题没想到，赛后觉得不难想。 要多练。 等过一段时间回过头看自己这套题才考这点分，就会觉得自己多么的菜。","link":"/2019/07/31/襄阳四中NOIP-2019-模拟赛-题解/"}],"tags":[{"name":"树上问题","slug":"树上问题","link":"/tags/树上问题/"},{"name":"根号分治","slug":"根号分治","link":"/tags/根号分治/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"模拟","slug":"模拟","link":"/tags/模拟/"},{"name":"Floyd","slug":"Floyd","link":"/tags/Floyd/"},{"name":"栈","slug":"栈","link":"/tags/栈/"},{"name":"Tarjan","slug":"Tarjan","link":"/tags/Tarjan/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"树形DP","slug":"树形DP","link":"/tags/树形DP/"},{"name":"游记","slug":"游记","link":"/tags/游记/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"递推","slug":"递推","link":"/tags/递推/"},{"name":"MST","slug":"MST","link":"/tags/MST/"},{"name":"强连通分量","slug":"强连通分量","link":"/tags/强连通分量/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"网络流","slug":"网络流","link":"/tags/网络流/"},{"name":"最小费用最大流","slug":"最小费用最大流","link":"/tags/最小费用最大流/"},{"name":"建图","slug":"建图","link":"/tags/建图/"},{"name":"树链剖分","slug":"树链剖分","link":"/tags/树链剖分/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"分类讨论","slug":"分类讨论","link":"/tags/分类讨论/"},{"name":"矩阵快速幂","slug":"矩阵快速幂","link":"/tags/矩阵快速幂/"},{"name":"实域二分","slug":"实域二分","link":"/tags/实域二分/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"树上差分","slug":"树上差分","link":"/tags/树上差分/"},{"name":"组合计数","slug":"组合计数","link":"/tags/组合计数/"},{"name":"树的直径","slug":"树的直径","link":"/tags/树的直径/"},{"name":"树上dp","slug":"树上dp","link":"/tags/树上dp/"},{"name":"传递闭包","slug":"传递闭包","link":"/tags/传递闭包/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"博弈论","slug":"博弈论","link":"/tags/博弈论/"},{"name":"Nim博弈","slug":"Nim博弈","link":"/tags/Nim博弈/"},{"name":"瞎搞","slug":"瞎搞","link":"/tags/瞎搞/"},{"name":"py3","slug":"py3","link":"/tags/py3/"},{"name":"多项式","slug":"多项式","link":"/tags/多项式/"},{"name":"FFT","slug":"FFT","link":"/tags/FFT/"},{"name":"ToDoList","slug":"ToDoList","link":"/tags/ToDoList/"},{"name":"Trie","slug":"Trie","link":"/tags/Trie/"},{"name":"位运算","slug":"位运算","link":"/tags/位运算/"},{"name":"状压","slug":"状压","link":"/tags/状压/"},{"name":"思维题","slug":"思维题","link":"/tags/思维题/"},{"name":"最短路","slug":"最短路","link":"/tags/最短路/"},{"name":"技术","slug":"技术","link":"/tags/技术/"},{"name":"Hash","slug":"Hash","link":"/tags/Hash/"},{"name":"时间复杂度分析","slug":"时间复杂度分析","link":"/tags/时间复杂度分析/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"exgcd","slug":"exgcd","link":"/tags/exgcd/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"组合数学","slug":"组合数学","link":"/tags/组合数学/"},{"name":"离散数学","slug":"离散数学","link":"/tags/离散数学/"},{"name":"矩阵","slug":"矩阵","link":"/tags/矩阵/"},{"name":"Kruskal","slug":"Kruskal","link":"/tags/Kruskal/"},{"name":"前缀和","slug":"前缀和","link":"/tags/前缀和/"},{"name":"差分","slug":"差分","link":"/tags/差分/"},{"name":"概率期望DP","slug":"概率期望DP","link":"/tags/概率期望DP/"},{"name":"技巧","slug":"技巧","link":"/tags/技巧/"},{"name":"裴蜀定理","slug":"裴蜀定理","link":"/tags/裴蜀定理/"},{"name":"学习报告","slug":"学习报告","link":"/tags/学习报告/"},{"name":"组合数递推","slug":"组合数递推","link":"/tags/组合数递推/"},{"name":"LCT","slug":"LCT","link":"/tags/LCT/"}],"categories":[{"name":"解题报告","slug":"解题报告","link":"/categories/解题报告/"},{"name":"游记","slug":"游记","link":"/categories/游记/"},{"name":"学习报告","slug":"学习报告","link":"/categories/学习报告/"},{"name":"置顶","slug":"置顶","link":"/categories/置顶/"},{"name":"写着van","slug":"写着van","link":"/categories/写着van/"}]}